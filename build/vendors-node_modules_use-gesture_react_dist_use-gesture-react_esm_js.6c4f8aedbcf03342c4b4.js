/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkproductionproject"] = self["webpackChunkproductionproject"] || []).push([["vendors-node_modules_use-gesture_react_dist_use-gesture-react_esm_js"],{

/***/ "./node_modules/@use-gesture/core/actions/dist/use-gesture-core-actions.esm.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@use-gesture/core/actions/dist/use-gesture-core-actions.esm.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ConfigResolverMap\": function() { return /* reexport safe */ _dist_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.C; },\n/* harmony export */   \"EngineMap\": function() { return /* reexport safe */ _dist_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.E; },\n/* harmony export */   \"dragAction\": function() { return /* reexport safe */ _dist_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.e; },\n/* harmony export */   \"hoverAction\": function() { return /* reexport safe */ _dist_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.h; },\n/* harmony export */   \"moveAction\": function() { return /* reexport safe */ _dist_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.m; },\n/* harmony export */   \"pinchAction\": function() { return /* reexport safe */ _dist_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.f; },\n/* harmony export */   \"registerAction\": function() { return /* reexport safe */ _dist_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.r; },\n/* harmony export */   \"scrollAction\": function() { return /* reexport safe */ _dist_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.s; },\n/* harmony export */   \"wheelAction\": function() { return /* reexport safe */ _dist_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.w; }\n/* harmony export */ });\n/* harmony import */ var _dist_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dist/actions-76b8683e.esm.js */ \"./node_modules/@use-gesture/core/dist/actions-76b8683e.esm.js\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVzZS1nZXN0dXJlL2NvcmUvYWN0aW9ucy9kaXN0L3VzZS1nZXN0dXJlLWNvcmUtYWN0aW9ucy5lc20uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9kdWN0aW9ucHJvamVjdC8uL25vZGVfbW9kdWxlcy9AdXNlLWdlc3R1cmUvY29yZS9hY3Rpb25zL2Rpc3QvdXNlLWdlc3R1cmUtY29yZS1hY3Rpb25zLmVzbS5qcz82YTlmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IEMgYXMgQ29uZmlnUmVzb2x2ZXJNYXAsIEUgYXMgRW5naW5lTWFwLCBlIGFzIGRyYWdBY3Rpb24sIGggYXMgaG92ZXJBY3Rpb24sIG0gYXMgbW92ZUFjdGlvbiwgZiBhcyBwaW5jaEFjdGlvbiwgciBhcyByZWdpc3RlckFjdGlvbiwgcyBhcyBzY3JvbGxBY3Rpb24sIHcgYXMgd2hlZWxBY3Rpb24gfSBmcm9tICcuLi8uLi9kaXN0L2FjdGlvbnMtNzZiODY4M2UuZXNtLmpzJztcbmltcG9ydCAnLi4vLi4vZGlzdC9tYXRocy0wYWIzOWFlOS5lc20uanMnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@use-gesture/core/actions/dist/use-gesture-core-actions.esm.js\n");

/***/ }),

/***/ "./node_modules/@use-gesture/core/dist/actions-76b8683e.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@use-gesture/core/dist/actions-76b8683e.esm.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"C\": function() { return /* binding */ ConfigResolverMap; },\n/* harmony export */   \"E\": function() { return /* binding */ EngineMap; },\n/* harmony export */   \"S\": function() { return /* binding */ SUPPORT; },\n/* harmony export */   \"_\": function() { return /* binding */ _objectSpread2; },\n/* harmony export */   \"a\": function() { return /* binding */ _defineProperty; },\n/* harmony export */   \"b\": function() { return /* binding */ touchIds; },\n/* harmony export */   \"c\": function() { return /* binding */ chain; },\n/* harmony export */   \"d\": function() { return /* binding */ toHandlerProp; },\n/* harmony export */   \"e\": function() { return /* binding */ dragAction; },\n/* harmony export */   \"f\": function() { return /* binding */ pinchAction; },\n/* harmony export */   \"h\": function() { return /* binding */ hoverAction; },\n/* harmony export */   \"i\": function() { return /* binding */ isTouch; },\n/* harmony export */   \"m\": function() { return /* binding */ moveAction; },\n/* harmony export */   \"p\": function() { return /* binding */ parseProp; },\n/* harmony export */   \"r\": function() { return /* binding */ registerAction; },\n/* harmony export */   \"s\": function() { return /* binding */ scrollAction; },\n/* harmony export */   \"t\": function() { return /* binding */ toDomEventType; },\n/* harmony export */   \"w\": function() { return /* binding */ wheelAction; }\n/* harmony export */ });\n/* harmony import */ var _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./maths-0ab39ae9.esm.js */ \"./node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js\");\n\n\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\n\nconst EVENT_TYPE_MAP = {\n  pointer: {\n    start: 'down',\n    change: 'move',\n    end: 'up'\n  },\n  mouse: {\n    start: 'down',\n    change: 'move',\n    end: 'up'\n  },\n  touch: {\n    start: 'start',\n    change: 'move',\n    end: 'end'\n  },\n  gesture: {\n    start: 'start',\n    change: 'change',\n    end: 'end'\n  }\n};\nfunction capitalize(string) {\n  if (!string) return '';\n  return string[0].toUpperCase() + string.slice(1);\n}\nconst actionsWithoutCaptureSupported = ['enter', 'leave'];\nfunction hasCapture(capture = false, actionKey) {\n  return capture && !actionsWithoutCaptureSupported.includes(actionKey);\n}\nfunction toHandlerProp(device, action = '', capture = false) {\n  const deviceProps = EVENT_TYPE_MAP[device];\n  const actionKey = deviceProps ? deviceProps[action] || action : action;\n  return 'on' + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? 'Capture' : '');\n}\nconst pointerCaptureEvents = ['gotpointercapture', 'lostpointercapture'];\nfunction parseProp(prop) {\n  let eventKey = prop.substring(2).toLowerCase();\n  const passive = !!~eventKey.indexOf('passive');\n  if (passive) eventKey = eventKey.replace('passive', '');\n  const captureKey = pointerCaptureEvents.includes(eventKey) ? 'capturecapture' : 'capture';\n  const capture = !!~eventKey.indexOf(captureKey);\n  if (capture) eventKey = eventKey.replace('capture', '');\n  return {\n    device: eventKey,\n    capture,\n    passive\n  };\n}\nfunction toDomEventType(device, action = '') {\n  const deviceProps = EVENT_TYPE_MAP[device];\n  const actionKey = deviceProps ? deviceProps[action] || action : action;\n  return device + actionKey;\n}\nfunction isTouch(event) {\n  return 'touches' in event;\n}\nfunction getPointerType(event) {\n  if (isTouch(event)) return 'touch';\n  if ('pointerType' in event) return event.pointerType;\n  return 'mouse';\n}\nfunction getCurrentTargetTouchList(event) {\n  return Array.from(event.touches).filter(e => {\n    var _event$currentTarget, _event$currentTarget$;\n    return e.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e.target));\n  });\n}\nfunction getTouchList(event) {\n  return event.type === 'touchend' || event.type === 'touchcancel' ? event.changedTouches : event.targetTouches;\n}\nfunction getValueEvent(event) {\n  return isTouch(event) ? getTouchList(event)[0] : event;\n}\nfunction distanceAngle(P1, P2) {\n  try {\n    const dx = P2.clientX - P1.clientX;\n    const dy = P2.clientY - P1.clientY;\n    const cx = (P2.clientX + P1.clientX) / 2;\n    const cy = (P2.clientY + P1.clientY) / 2;\n    const distance = Math.hypot(dx, dy);\n    const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;\n    const origin = [cx, cy];\n    return {\n      angle,\n      distance,\n      origin\n    };\n  } catch (_unused) {}\n  return null;\n}\nfunction touchIds(event) {\n  return getCurrentTargetTouchList(event).map(touch => touch.identifier);\n}\nfunction touchDistanceAngle(event, ids) {\n  const [P1, P2] = Array.from(event.touches).filter(touch => ids.includes(touch.identifier));\n  return distanceAngle(P1, P2);\n}\nfunction pointerId(event) {\n  const valueEvent = getValueEvent(event);\n  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;\n}\nfunction pointerValues(event) {\n  const valueEvent = getValueEvent(event);\n  return [valueEvent.clientX, valueEvent.clientY];\n}\nconst LINE_HEIGHT = 40;\nconst PAGE_HEIGHT = 800;\nfunction wheelValues(event) {\n  let {\n    deltaX,\n    deltaY,\n    deltaMode\n  } = event;\n  if (deltaMode === 1) {\n    deltaX *= LINE_HEIGHT;\n    deltaY *= LINE_HEIGHT;\n  } else if (deltaMode === 2) {\n    deltaX *= PAGE_HEIGHT;\n    deltaY *= PAGE_HEIGHT;\n  }\n  return [deltaX, deltaY];\n}\nfunction scrollValues(event) {\n  var _ref, _ref2;\n  const {\n    scrollX,\n    scrollY,\n    scrollLeft,\n    scrollTop\n  } = event.currentTarget;\n  return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];\n}\nfunction getEventDetails(event) {\n  const payload = {};\n  if ('buttons' in event) payload.buttons = event.buttons;\n  if ('shiftKey' in event) {\n    const {\n      shiftKey,\n      altKey,\n      metaKey,\n      ctrlKey\n    } = event;\n    Object.assign(payload, {\n      shiftKey,\n      altKey,\n      metaKey,\n      ctrlKey\n    });\n  }\n  return payload;\n}\n\nfunction call(v, ...args) {\n  if (typeof v === 'function') {\n    return v(...args);\n  } else {\n    return v;\n  }\n}\nfunction noop() {}\nfunction chain(...fns) {\n  if (fns.length === 0) return noop;\n  if (fns.length === 1) return fns[0];\n  return function () {\n    let result;\n    for (const fn of fns) {\n      result = fn.apply(this, arguments) || result;\n    }\n    return result;\n  };\n}\nfunction assignDefault(value, fallback) {\n  return Object.assign({}, fallback, value || {});\n}\n\nconst BEFORE_LAST_KINEMATICS_DELAY = 32;\nclass Engine {\n  constructor(ctrl, args, key) {\n    this.ctrl = ctrl;\n    this.args = args;\n    this.key = key;\n    if (!this.state) {\n      this.state = {};\n      this.computeValues([0, 0]);\n      this.computeInitial();\n      if (this.init) this.init();\n      this.reset();\n    }\n  }\n  get state() {\n    return this.ctrl.state[this.key];\n  }\n  set state(state) {\n    this.ctrl.state[this.key] = state;\n  }\n  get shared() {\n    return this.ctrl.state.shared;\n  }\n  get eventStore() {\n    return this.ctrl.gestureEventStores[this.key];\n  }\n  get timeoutStore() {\n    return this.ctrl.gestureTimeoutStores[this.key];\n  }\n  get config() {\n    return this.ctrl.config[this.key];\n  }\n  get sharedConfig() {\n    return this.ctrl.config.shared;\n  }\n  get handler() {\n    return this.ctrl.handlers[this.key];\n  }\n  reset() {\n    const {\n      state,\n      shared,\n      ingKey,\n      args\n    } = this;\n    shared[ingKey] = state._active = state.active = state._blocked = state._force = false;\n    state._step = [false, false];\n    state.intentional = false;\n    state._movement = [0, 0];\n    state._distance = [0, 0];\n    state._direction = [0, 0];\n    state._delta = [0, 0];\n    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];\n    state.args = args;\n    state.axis = undefined;\n    state.memo = undefined;\n    state.elapsedTime = state.timeDelta = 0;\n    state.direction = [0, 0];\n    state.distance = [0, 0];\n    state.overflow = [0, 0];\n    state._movementBound = [false, false];\n    state.velocity = [0, 0];\n    state.movement = [0, 0];\n    state.delta = [0, 0];\n    state.timeStamp = 0;\n  }\n  start(event) {\n    const state = this.state;\n    const config = this.config;\n    if (!state._active) {\n      this.reset();\n      this.computeInitial();\n      state._active = true;\n      state.target = event.target;\n      state.currentTarget = event.currentTarget;\n      state.lastOffset = config.from ? call(config.from, state) : state.offset;\n      state.offset = state.lastOffset;\n      state.startTime = state.timeStamp = event.timeStamp;\n    }\n  }\n  computeValues(values) {\n    const state = this.state;\n    state._values = values;\n    state.values = this.config.transform(values);\n  }\n  computeInitial() {\n    const state = this.state;\n    state._initial = state._values;\n    state.initial = state.values;\n  }\n  compute(event) {\n    const {\n      state,\n      config,\n      shared\n    } = this;\n    state.args = this.args;\n    let dt = 0;\n    if (event) {\n      state.event = event;\n      if (config.preventDefault && event.cancelable) state.event.preventDefault();\n      state.type = event.type;\n      shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;\n      shared.locked = !!document.pointerLockElement;\n      Object.assign(shared, getEventDetails(event));\n      shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;\n      dt = event.timeStamp - state.timeStamp;\n      state.timeStamp = event.timeStamp;\n      state.elapsedTime = state.timeStamp - state.startTime;\n    }\n    if (state._active) {\n      const _absoluteDelta = state._delta.map(Math.abs);\n      _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._distance, _absoluteDelta);\n    }\n    if (this.axisIntent) this.axisIntent(event);\n    const [_m0, _m1] = state._movement;\n    const [t0, t1] = config.threshold;\n    const {\n      _step,\n      values\n    } = state;\n    if (config.hasCustomTransform) {\n      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && values[0];\n      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && values[1];\n    } else {\n      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;\n      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;\n    }\n    state.intentional = _step[0] !== false || _step[1] !== false;\n    if (!state.intentional) return;\n    const movement = [0, 0];\n    if (config.hasCustomTransform) {\n      const [v0, v1] = values;\n      movement[0] = _step[0] !== false ? v0 - _step[0] : 0;\n      movement[1] = _step[1] !== false ? v1 - _step[1] : 0;\n    } else {\n      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;\n      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;\n    }\n    if (this.restrictToAxis && !state._blocked) this.restrictToAxis(movement);\n    const previousOffset = state.offset;\n    const gestureIsActive = state._active && !state._blocked || state.active;\n    if (gestureIsActive) {\n      state.first = state._active && !state.active;\n      state.last = !state._active && state.active;\n      state.active = shared[this.ingKey] = state._active;\n      if (event) {\n        if (state.first) {\n          if ('bounds' in config) state._bounds = call(config.bounds, state);\n          if (this.setup) this.setup();\n        }\n        state.movement = movement;\n        this.computeOffset();\n      }\n    }\n    const [ox, oy] = state.offset;\n    const [[x0, x1], [y0, y1]] = state._bounds;\n    state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];\n    state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;\n    state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;\n    const rubberband = state._active ? config.rubberband || [0, 0] : [0, 0];\n    state.offset = (0,_maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(state._bounds, state.offset, rubberband);\n    state.delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(state.offset, previousOffset);\n    this.computeMovement();\n    if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {\n      state.delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(state.offset, previousOffset);\n      const absoluteDelta = state.delta.map(Math.abs);\n      _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state.distance, absoluteDelta);\n      state.direction = state.delta.map(Math.sign);\n      state._direction = state._delta.map(Math.sign);\n      if (!state.first && dt > 0) {\n        state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];\n        state.timeDelta = dt;\n      }\n    }\n  }\n  emit() {\n    const state = this.state;\n    const shared = this.shared;\n    const config = this.config;\n    if (!state._active) this.clean();\n    if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents) return;\n    const memo = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {\n      [this.aliasKey]: state.values\n    }));\n    if (memo !== undefined) state.memo = memo;\n  }\n  clean() {\n    this.eventStore.clean();\n    this.timeoutStore.clean();\n  }\n}\n\nfunction selectAxis([dx, dy], threshold) {\n  const absDx = Math.abs(dx);\n  const absDy = Math.abs(dy);\n  if (absDx > absDy && absDx > threshold) {\n    return 'x';\n  }\n  if (absDy > absDx && absDy > threshold) {\n    return 'y';\n  }\n  return undefined;\n}\nclass CoordinatesEngine extends Engine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"aliasKey\", 'xy');\n  }\n  reset() {\n    super.reset();\n    this.state.axis = undefined;\n  }\n  init() {\n    this.state.offset = [0, 0];\n    this.state.lastOffset = [0, 0];\n  }\n  computeOffset() {\n    this.state.offset = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.add(this.state.lastOffset, this.state.movement);\n  }\n  computeMovement() {\n    this.state.movement = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(this.state.offset, this.state.lastOffset);\n  }\n  axisIntent(event) {\n    const state = this.state;\n    const config = this.config;\n    if (!state.axis && event) {\n      const threshold = typeof config.axisThreshold === 'object' ? config.axisThreshold[getPointerType(event)] : config.axisThreshold;\n      state.axis = selectAxis(state._movement, threshold);\n    }\n    state._blocked = (config.lockDirection || !!config.axis) && !state.axis || !!config.axis && config.axis !== state.axis;\n  }\n  restrictToAxis(v) {\n    if (this.config.axis || this.config.lockDirection) {\n      switch (this.state.axis) {\n        case 'x':\n          v[1] = 0;\n          break;\n        case 'y':\n          v[0] = 0;\n          break;\n      }\n    }\n  }\n}\n\nconst identity = v => v;\nconst DEFAULT_RUBBERBAND = 0.15;\nconst commonConfigResolver = {\n  enabled(value = true) {\n    return value;\n  },\n  eventOptions(value, _k, config) {\n    return _objectSpread2(_objectSpread2({}, config.shared.eventOptions), value);\n  },\n  preventDefault(value = false) {\n    return value;\n  },\n  triggerAllEvents(value = false) {\n    return value;\n  },\n  rubberband(value = 0) {\n    switch (value) {\n      case true:\n        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];\n      case false:\n        return [0, 0];\n      default:\n        return _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(value);\n    }\n  },\n  from(value) {\n    if (typeof value === 'function') return value;\n    if (value != null) return _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(value);\n  },\n  transform(value, _k, config) {\n    const transform = value || config.shared.transform;\n    this.hasCustomTransform = !!transform;\n    if (true) {\n      const originalTransform = transform || identity;\n      return v => {\n        const r = originalTransform(v);\n        if (!isFinite(r[0]) || !isFinite(r[1])) {\n          console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r[0]},${[1]}]`);\n        }\n        return r;\n      };\n    }\n    return transform || identity;\n  },\n  threshold(value) {\n    return _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(value, 0);\n  }\n};\nif (true) {\n  Object.assign(commonConfigResolver, {\n    domTarget(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`domTarget\\` option has been renamed to \\`target\\`.`);\n      }\n      return NaN;\n    },\n    lockDirection(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`lockDirection\\` option has been merged with \\`axis\\`. Use it as in \\`{ axis: 'lock' }\\``);\n      }\n      return NaN;\n    },\n    initial(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`initial\\` option has been renamed to \\`from\\`.`);\n      }\n      return NaN;\n    }\n  });\n}\n\nconst DEFAULT_AXIS_THRESHOLD = 0;\nconst coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  axis(_v, _k, {\n    axis\n  }) {\n    this.lockDirection = axis === 'lock';\n    if (!this.lockDirection) return axis;\n  },\n  axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {\n    return value;\n  },\n  bounds(value = {}) {\n    if (typeof value === 'function') {\n      return state => coordinatesConfigResolver.bounds(value(state));\n    }\n    if ('current' in value) {\n      return () => value.current;\n    }\n    if (typeof HTMLElement === 'function' && value instanceof HTMLElement) {\n      return value;\n    }\n    const {\n      left = -Infinity,\n      right = Infinity,\n      top = -Infinity,\n      bottom = Infinity\n    } = value;\n    return [[left, right], [top, bottom]];\n  }\n});\n\nconst KEYS_DELTA_MAP = {\n  ArrowRight: (displacement, factor = 1) => [displacement * factor, 0],\n  ArrowLeft: (displacement, factor = 1) => [-1 * displacement * factor, 0],\n  ArrowUp: (displacement, factor = 1) => [0, -1 * displacement * factor],\n  ArrowDown: (displacement, factor = 1) => [0, displacement * factor]\n};\nclass DragEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'dragging');\n  }\n  reset() {\n    super.reset();\n    const state = this.state;\n    state._pointerId = undefined;\n    state._pointerActive = false;\n    state._keyboardActive = false;\n    state._preventScroll = false;\n    state._delayed = false;\n    state.swipe = [0, 0];\n    state.tap = false;\n    state.canceled = false;\n    state.cancel = this.cancel.bind(this);\n  }\n  setup() {\n    const state = this.state;\n    if (state._bounds instanceof HTMLElement) {\n      const boundRect = state._bounds.getBoundingClientRect();\n      const targetRect = state.currentTarget.getBoundingClientRect();\n      const _bounds = {\n        left: boundRect.left - targetRect.left + state.offset[0],\n        right: boundRect.right - targetRect.right + state.offset[0],\n        top: boundRect.top - targetRect.top + state.offset[1],\n        bottom: boundRect.bottom - targetRect.bottom + state.offset[1]\n      };\n      state._bounds = coordinatesConfigResolver.bounds(_bounds);\n    }\n  }\n  cancel() {\n    const state = this.state;\n    if (state.canceled) return;\n    state.canceled = true;\n    state._active = false;\n    setTimeout(() => {\n      this.compute();\n      this.emit();\n    }, 0);\n  }\n  setActive() {\n    this.state._active = this.state._pointerActive || this.state._keyboardActive;\n  }\n  clean() {\n    this.pointerClean();\n    this.state._pointerActive = false;\n    this.state._keyboardActive = false;\n    super.clean();\n  }\n  pointerDown(event) {\n    const config = this.config;\n    const state = this.state;\n    if (event.buttons != null && (Array.isArray(config.pointerButtons) ? !config.pointerButtons.includes(event.buttons) : config.pointerButtons !== -1 && config.pointerButtons !== event.buttons)) return;\n    const ctrlIds = this.ctrl.setEventIds(event);\n    if (config.pointerCapture) {\n      event.target.setPointerCapture(event.pointerId);\n    }\n    if (ctrlIds && ctrlIds.size > 1 && state._pointerActive) return;\n    this.start(event);\n    this.setupPointer(event);\n    state._pointerId = pointerId(event);\n    state._pointerActive = true;\n    this.computeValues(pointerValues(event));\n    this.computeInitial();\n    if (config.preventScrollAxis && getPointerType(event) !== 'mouse') {\n      state._active = false;\n      this.setupScrollPrevention(event);\n    } else if (config.delay > 0) {\n      this.setupDelayTrigger(event);\n      if (config.triggerAllEvents) {\n        this.compute(event);\n        this.emit();\n      }\n    } else {\n      this.startPointerDrag(event);\n    }\n  }\n  startPointerDrag(event) {\n    const state = this.state;\n    state._active = true;\n    state._preventScroll = true;\n    state._delayed = false;\n    this.compute(event);\n    this.emit();\n  }\n  pointerMove(event) {\n    const state = this.state;\n    const config = this.config;\n    if (!state._pointerActive) return;\n    const id = pointerId(event);\n    if (state._pointerId !== undefined && id !== state._pointerId) return;\n    const _values = pointerValues(event);\n    if (document.pointerLockElement === event.target) {\n      state._delta = [event.movementX, event.movementY];\n    } else {\n      state._delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(_values, state._values);\n      this.computeValues(_values);\n    }\n    _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);\n    this.compute(event);\n    if (state._delayed && state.intentional) {\n      this.timeoutStore.remove('dragDelay');\n      state.active = false;\n      this.startPointerDrag(event);\n      return;\n    }\n    if (config.preventScrollAxis && !state._preventScroll) {\n      if (state.axis) {\n        if (state.axis === config.preventScrollAxis || config.preventScrollAxis === 'xy') {\n          state._active = false;\n          this.clean();\n          return;\n        } else {\n          this.timeoutStore.remove('startPointerDrag');\n          this.startPointerDrag(event);\n          return;\n        }\n      } else {\n        return;\n      }\n    }\n    this.emit();\n  }\n  pointerUp(event) {\n    this.ctrl.setEventIds(event);\n    try {\n      if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {\n        ;\n        event.target.releasePointerCapture(event.pointerId);\n      }\n    } catch (_unused) {\n      if (true) {\n        console.warn(`[@use-gesture]: If you see this message, it's likely that you're using an outdated version of \\`@react-three/fiber\\`. \\n\\nPlease upgrade to the latest version.`);\n      }\n    }\n    const state = this.state;\n    const config = this.config;\n    if (!state._active || !state._pointerActive) return;\n    const id = pointerId(event);\n    if (state._pointerId !== undefined && id !== state._pointerId) return;\n    this.state._pointerActive = false;\n    this.setActive();\n    this.compute(event);\n    const [dx, dy] = state._distance;\n    state.tap = dx <= config.tapsThreshold && dy <= config.tapsThreshold;\n    if (state.tap && config.filterTaps) {\n      state._force = true;\n    } else {\n      const [_dx, _dy] = state._delta;\n      const [_mx, _my] = state._movement;\n      const [svx, svy] = config.swipe.velocity;\n      const [sx, sy] = config.swipe.distance;\n      const sdt = config.swipe.duration;\n      if (state.elapsedTime < sdt) {\n        const _vx = Math.abs(_dx / state.timeDelta);\n        const _vy = Math.abs(_dy / state.timeDelta);\n        if (_vx > svx && Math.abs(_mx) > sx) state.swipe[0] = Math.sign(_dx);\n        if (_vy > svy && Math.abs(_my) > sy) state.swipe[1] = Math.sign(_dy);\n      }\n    }\n    this.emit();\n  }\n  pointerClick(event) {\n    if (!this.state.tap && event.detail > 0) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n  setupPointer(event) {\n    const config = this.config;\n    const device = config.device;\n    if (true) {\n      try {\n        if (device === 'pointer' && config.preventScrollDelay === undefined) {\n          const currentTarget = 'uv' in event ? event.sourceEvent.currentTarget : event.currentTarget;\n          const style = window.getComputedStyle(currentTarget);\n          if (style.touchAction === 'auto') {\n            console.warn(`[@use-gesture]: The drag target has its \\`touch-action\\` style property set to \\`auto\\`. It is recommended to add \\`touch-action: 'none'\\` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.\\n\\nThis message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.`, currentTarget);\n          }\n        }\n      } catch (_unused2) {}\n    }\n    if (config.pointerLock) {\n      event.currentTarget.requestPointerLock();\n    }\n    if (!config.pointerCapture) {\n      this.eventStore.add(this.sharedConfig.window, device, 'change', this.pointerMove.bind(this));\n      this.eventStore.add(this.sharedConfig.window, device, 'end', this.pointerUp.bind(this));\n      this.eventStore.add(this.sharedConfig.window, device, 'cancel', this.pointerUp.bind(this));\n    }\n  }\n  pointerClean() {\n    if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {\n      document.exitPointerLock();\n    }\n  }\n  preventScroll(event) {\n    if (this.state._preventScroll && event.cancelable) {\n      event.preventDefault();\n    }\n  }\n  setupScrollPrevention(event) {\n    this.state._preventScroll = false;\n    persistEvent(event);\n    const remove = this.eventStore.add(this.sharedConfig.window, 'touch', 'change', this.preventScroll.bind(this), {\n      passive: false\n    });\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'end', remove);\n    this.eventStore.add(this.sharedConfig.window, 'touch', 'cancel', remove);\n    this.timeoutStore.add('startPointerDrag', this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);\n  }\n  setupDelayTrigger(event) {\n    this.state._delayed = true;\n    this.timeoutStore.add('dragDelay', () => {\n      this.state._step = [0, 0];\n      this.startPointerDrag(event);\n    }, this.config.delay);\n  }\n  keyDown(event) {\n    const deltaFn = KEYS_DELTA_MAP[event.key];\n    if (deltaFn) {\n      const state = this.state;\n      const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;\n      this.start(event);\n      state._delta = deltaFn(this.config.keyboardDisplacement, factor);\n      state._keyboardActive = true;\n      _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);\n      this.compute(event);\n      this.emit();\n    }\n  }\n  keyUp(event) {\n    if (!(event.key in KEYS_DELTA_MAP)) return;\n    this.state._keyboardActive = false;\n    this.setActive();\n    this.compute(event);\n    this.emit();\n  }\n  bind(bindFunction) {\n    const device = this.config.device;\n    bindFunction(device, 'start', this.pointerDown.bind(this));\n    if (this.config.pointerCapture) {\n      bindFunction(device, 'change', this.pointerMove.bind(this));\n      bindFunction(device, 'end', this.pointerUp.bind(this));\n      bindFunction(device, 'cancel', this.pointerUp.bind(this));\n      bindFunction('lostPointerCapture', '', this.pointerUp.bind(this));\n    }\n    if (this.config.keys) {\n      bindFunction('key', 'down', this.keyDown.bind(this));\n      bindFunction('key', 'up', this.keyUp.bind(this));\n    }\n    if (this.config.filterTaps) {\n      bindFunction('click', '', this.pointerClick.bind(this), {\n        capture: true,\n        passive: false\n      });\n    }\n  }\n}\nfunction persistEvent(event) {\n  'persist' in event && typeof event.persist === 'function' && event.persist();\n}\n\nconst isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement;\nfunction supportsTouchEvents() {\n  return isBrowser && 'ontouchstart' in window;\n}\nfunction isTouchScreen() {\n  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;\n}\nfunction supportsPointerEvents() {\n  return isBrowser && 'onpointerdown' in window;\n}\nfunction supportsPointerLock() {\n  return isBrowser && 'exitPointerLock' in window.document;\n}\nfunction supportsGestureEvents() {\n  try {\n    return 'constructor' in GestureEvent;\n  } catch (e) {\n    return false;\n  }\n}\nconst SUPPORT = {\n  isBrowser,\n  gesture: supportsGestureEvents(),\n  touch: isTouchScreen(),\n  touchscreen: isTouchScreen(),\n  pointer: supportsPointerEvents(),\n  pointerLock: supportsPointerLock()\n};\n\nconst DEFAULT_PREVENT_SCROLL_DELAY = 250;\nconst DEFAULT_DRAG_DELAY = 180;\nconst DEFAULT_SWIPE_VELOCITY = 0.5;\nconst DEFAULT_SWIPE_DISTANCE = 50;\nconst DEFAULT_SWIPE_DURATION = 250;\nconst DEFAULT_KEYBOARD_DISPLACEMENT = 10;\nconst DEFAULT_DRAG_AXIS_THRESHOLD = {\n  mouse: 0,\n  touch: 0,\n  pen: 8\n};\nconst dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  device(_v, _k, {\n    pointer: {\n      touch = false,\n      lock = false,\n      mouse = false\n    } = {}\n  }) {\n    this.pointerLock = lock && SUPPORT.pointerLock;\n    if (SUPPORT.touch && touch) return 'touch';\n    if (this.pointerLock) return 'mouse';\n    if (SUPPORT.pointer && !mouse) return 'pointer';\n    if (SUPPORT.touch) return 'touch';\n    return 'mouse';\n  },\n  preventScrollAxis(value, _k, {\n    preventScroll\n  }) {\n    this.preventScrollDelay = typeof preventScroll === 'number' ? preventScroll : preventScroll || preventScroll === undefined && value ? DEFAULT_PREVENT_SCROLL_DELAY : undefined;\n    if (!SUPPORT.touchscreen || preventScroll === false) return undefined;\n    return value ? value : preventScroll !== undefined ? 'y' : undefined;\n  },\n  pointerCapture(_v, _k, {\n    pointer: {\n      capture = true,\n      buttons = 1,\n      keys = true\n    } = {}\n  }) {\n    this.pointerButtons = buttons;\n    this.keys = keys;\n    return !this.pointerLock && this.device === 'pointer' && capture;\n  },\n  threshold(value, _k, {\n    filterTaps = false,\n    tapsThreshold = 3,\n    axis = undefined\n  }) {\n    const threshold = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);\n    this.filterTaps = filterTaps;\n    this.tapsThreshold = tapsThreshold;\n    return threshold;\n  },\n  swipe({\n    velocity = DEFAULT_SWIPE_VELOCITY,\n    distance = DEFAULT_SWIPE_DISTANCE,\n    duration = DEFAULT_SWIPE_DURATION\n  } = {}) {\n    return {\n      velocity: this.transform(_maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(velocity)),\n      distance: this.transform(_maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(distance)),\n      duration\n    };\n  },\n  delay(value = 0) {\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY;\n      case false:\n        return 0;\n      default:\n        return value;\n    }\n  },\n  axisThreshold(value) {\n    if (!value) return DEFAULT_DRAG_AXIS_THRESHOLD;\n    return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);\n  },\n  keyboardDisplacement(value = DEFAULT_KEYBOARD_DISPLACEMENT) {\n    return value;\n  }\n});\nif (true) {\n  Object.assign(dragConfigResolver, {\n    useTouch(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`useTouch\\` option has been renamed to \\`pointer.touch\\`. Use it as in \\`{ pointer: { touch: true } }\\`.`);\n      }\n      return NaN;\n    },\n    experimental_preventWindowScrollY(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`experimental_preventWindowScrollY\\` option has been renamed to \\`preventScroll\\`.`);\n      }\n      return NaN;\n    },\n    swipeVelocity(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeVelocity\\` option has been renamed to \\`swipe.velocity\\`. Use it as in \\`{ swipe: { velocity: 0.5 } }\\`.`);\n      }\n      return NaN;\n    },\n    swipeDistance(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeDistance\\` option has been renamed to \\`swipe.distance\\`. Use it as in \\`{ swipe: { distance: 50 } }\\`.`);\n      }\n      return NaN;\n    },\n    swipeDuration(value) {\n      if (value !== undefined) {\n        throw Error(`[@use-gesture]: \\`swipeDuration\\` option has been renamed to \\`swipe.duration\\`. Use it as in \\`{ swipe: { duration: 250 } }\\`.`);\n      }\n      return NaN;\n    }\n  });\n}\n\nfunction clampStateInternalMovementToBounds(state) {\n  const [ox, oy] = state.overflow;\n  const [dx, dy] = state._delta;\n  const [dirx, diry] = state._direction;\n  if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {\n    state._movement[0] = state._movementBound[0];\n  }\n  if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {\n    state._movement[1] = state._movementBound[1];\n  }\n}\n\nconst SCALE_ANGLE_RATIO_INTENT_DEG = 30;\nconst PINCH_WHEEL_RATIO = 100;\nclass PinchEngine extends Engine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'pinching');\n    _defineProperty(this, \"aliasKey\", 'da');\n  }\n  init() {\n    this.state.offset = [1, 0];\n    this.state.lastOffset = [1, 0];\n    this.state._pointerEvents = new Map();\n  }\n  reset() {\n    super.reset();\n    const state = this.state;\n    state._touchIds = [];\n    state.canceled = false;\n    state.cancel = this.cancel.bind(this);\n    state.turns = 0;\n  }\n  computeOffset() {\n    const {\n      type,\n      movement,\n      lastOffset\n    } = this.state;\n    if (type === 'wheel') {\n      this.state.offset = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.add(movement, lastOffset);\n    } else {\n      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];\n    }\n  }\n  computeMovement() {\n    const {\n      offset,\n      lastOffset\n    } = this.state;\n    this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]];\n  }\n  axisIntent() {\n    const state = this.state;\n    const [_m0, _m1] = state._movement;\n    if (!state.axis) {\n      const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);\n      if (axisMovementDifference < 0) state.axis = 'angle';else if (axisMovementDifference > 0) state.axis = 'scale';\n    }\n  }\n  restrictToAxis(v) {\n    if (this.config.lockDirection) {\n      if (this.state.axis === 'scale') v[1] = 0;else if (this.state.axis === 'angle') v[0] = 0;\n    }\n  }\n  cancel() {\n    const state = this.state;\n    if (state.canceled) return;\n    setTimeout(() => {\n      state.canceled = true;\n      state._active = false;\n      this.compute();\n      this.emit();\n    }, 0);\n  }\n  touchStart(event) {\n    this.ctrl.setEventIds(event);\n    const state = this.state;\n    const ctrlTouchIds = this.ctrl.touchIds;\n    if (state._active) {\n      if (state._touchIds.every(id => ctrlTouchIds.has(id))) return;\n    }\n    if (ctrlTouchIds.size < 2) return;\n    this.start(event);\n    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);\n    const payload = touchDistanceAngle(event, state._touchIds);\n    if (!payload) return;\n    this.pinchStart(event, payload);\n  }\n  pointerStart(event) {\n    if (event.buttons != null && event.buttons % 2 !== 1) return;\n    this.ctrl.setEventIds(event);\n    event.target.setPointerCapture(event.pointerId);\n    const state = this.state;\n    const _pointerEvents = state._pointerEvents;\n    const ctrlPointerIds = this.ctrl.pointerIds;\n    if (state._active) {\n      if (Array.from(_pointerEvents.keys()).every(id => ctrlPointerIds.has(id))) return;\n    }\n    if (_pointerEvents.size < 2) {\n      _pointerEvents.set(event.pointerId, event);\n    }\n    if (state._pointerEvents.size < 2) return;\n    this.start(event);\n    const payload = distanceAngle(...Array.from(_pointerEvents.values()));\n    if (!payload) return;\n    this.pinchStart(event, payload);\n  }\n  pinchStart(event, payload) {\n    const state = this.state;\n    state.origin = payload.origin;\n    this.computeValues([payload.distance, payload.angle]);\n    this.computeInitial();\n    this.compute(event);\n    this.emit();\n  }\n  touchMove(event) {\n    if (!this.state._active) return;\n    const payload = touchDistanceAngle(event, this.state._touchIds);\n    if (!payload) return;\n    this.pinchMove(event, payload);\n  }\n  pointerMove(event) {\n    const _pointerEvents = this.state._pointerEvents;\n    if (_pointerEvents.has(event.pointerId)) {\n      _pointerEvents.set(event.pointerId, event);\n    }\n    if (!this.state._active) return;\n    const payload = distanceAngle(...Array.from(_pointerEvents.values()));\n    if (!payload) return;\n    this.pinchMove(event, payload);\n  }\n  pinchMove(event, payload) {\n    const state = this.state;\n    const prev_a = state._values[1];\n    const delta_a = payload.angle - prev_a;\n    let delta_turns = 0;\n    if (Math.abs(delta_a) > 270) delta_turns += Math.sign(delta_a);\n    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);\n    state.origin = payload.origin;\n    state.turns = delta_turns;\n    state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];\n    this.compute(event);\n    this.emit();\n  }\n  touchEnd(event) {\n    this.ctrl.setEventIds(event);\n    if (!this.state._active) return;\n    if (this.state._touchIds.some(id => !this.ctrl.touchIds.has(id))) {\n      this.state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }\n  pointerEnd(event) {\n    const state = this.state;\n    this.ctrl.setEventIds(event);\n    try {\n      event.target.releasePointerCapture(event.pointerId);\n    } catch (_unused) {}\n    if (state._pointerEvents.has(event.pointerId)) {\n      state._pointerEvents.delete(event.pointerId);\n    }\n    if (!state._active) return;\n    if (state._pointerEvents.size < 2) {\n      state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }\n  gestureStart(event) {\n    if (event.cancelable) event.preventDefault();\n    const state = this.state;\n    if (state._active) return;\n    this.start(event);\n    this.computeValues([event.scale, event.rotation]);\n    state.origin = [event.clientX, event.clientY];\n    this.compute(event);\n    this.emit();\n  }\n  gestureMove(event) {\n    if (event.cancelable) event.preventDefault();\n    if (!this.state._active) return;\n    const state = this.state;\n    this.computeValues([event.scale, event.rotation]);\n    state.origin = [event.clientX, event.clientY];\n    const _previousMovement = state._movement;\n    state._movement = [event.scale - 1, event.rotation];\n    state._delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(state._movement, _previousMovement);\n    this.compute(event);\n    this.emit();\n  }\n  gestureEnd(event) {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute(event);\n    this.emit();\n  }\n  wheel(event) {\n    const modifierKey = this.config.modifierKey;\n    if (modifierKey && !event[modifierKey]) return;\n    if (!this.state._active) this.wheelStart(event);else this.wheelChange(event);\n    this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));\n  }\n  wheelStart(event) {\n    this.start(event);\n    this.wheelChange(event);\n  }\n  wheelChange(event) {\n    const isR3f = ('uv' in event);\n    if (!isR3f) {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      if ( true && !event.defaultPrevented) {\n        console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \\`target\\` option.\\n\\nThis message will only appear in development mode.`);\n      }\n    }\n    const state = this.state;\n    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];\n    _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);\n    clampStateInternalMovementToBounds(state);\n    this.state.origin = [event.clientX, event.clientY];\n    this.compute(event);\n    this.emit();\n  }\n  wheelEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n  bind(bindFunction) {\n    const device = this.config.device;\n    if (!!device) {\n      bindFunction(device, 'start', this[device + 'Start'].bind(this));\n      bindFunction(device, 'change', this[device + 'Move'].bind(this));\n      bindFunction(device, 'end', this[device + 'End'].bind(this));\n      bindFunction(device, 'cancel', this[device + 'End'].bind(this));\n      bindFunction('lostPointerCapture', '', this[device + 'End'].bind(this));\n    }\n    if (this.config.pinchOnWheel) {\n      bindFunction('wheel', '', this.wheel.bind(this), {\n        passive: false\n      });\n    }\n  }\n}\n\nconst pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  device(_v, _k, {\n    shared,\n    pointer: {\n      touch = false\n    } = {}\n  }) {\n    const sharedConfig = shared;\n    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture) return 'gesture';\n    if (SUPPORT.touch && touch) return 'touch';\n    if (SUPPORT.touchscreen) {\n      if (SUPPORT.pointer) return 'pointer';\n      if (SUPPORT.touch) return 'touch';\n    }\n  },\n  bounds(_v, _k, {\n    scaleBounds = {},\n    angleBounds = {}\n  }) {\n    const _scaleBounds = state => {\n      const D = assignDefault(call(scaleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [D.min, D.max];\n    };\n    const _angleBounds = state => {\n      const A = assignDefault(call(angleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [A.min, A.max];\n    };\n    if (typeof scaleBounds !== 'function' && typeof angleBounds !== 'function') return [_scaleBounds(), _angleBounds()];\n    return state => [_scaleBounds(state), _angleBounds(state)];\n  },\n  threshold(value, _k, config) {\n    this.lockDirection = config.axis === 'lock';\n    const threshold = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(value, this.lockDirection ? [0.1, 3] : 0);\n    return threshold;\n  },\n  modifierKey(value) {\n    if (value === undefined) return 'ctrlKey';\n    return value;\n  },\n  pinchOnWheel(value = true) {\n    return value;\n  }\n});\n\nclass MoveEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'moving');\n  }\n  move(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    if (!this.state._active) this.moveStart(event);else this.moveChange(event);\n    this.timeoutStore.add('moveEnd', this.moveEnd.bind(this));\n  }\n  moveStart(event) {\n    this.start(event);\n    this.computeValues(pointerValues(event));\n    this.compute(event);\n    this.computeInitial();\n    this.emit();\n  }\n  moveChange(event) {\n    if (!this.state._active) return;\n    const values = pointerValues(event);\n    const state = this.state;\n    state._delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(values, state._values);\n    _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);\n    this.computeValues(values);\n    this.compute(event);\n    this.emit();\n  }\n  moveEnd(event) {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute(event);\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction('pointer', 'change', this.move.bind(this));\n    bindFunction('pointer', 'leave', this.moveEnd.bind(this));\n  }\n}\n\nconst moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: (value = true) => value\n});\n\nclass ScrollEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'scrolling');\n  }\n  scroll(event) {\n    if (!this.state._active) this.start(event);\n    this.scrollChange(event);\n    this.timeoutStore.add('scrollEnd', this.scrollEnd.bind(this));\n  }\n  scrollChange(event) {\n    if (event.cancelable) event.preventDefault();\n    const state = this.state;\n    const values = scrollValues(event);\n    state._delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(values, state._values);\n    _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);\n    this.computeValues(values);\n    this.compute(event);\n    this.emit();\n  }\n  scrollEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction('scroll', '', this.scroll.bind(this));\n  }\n}\n\nconst scrollConfigResolver = coordinatesConfigResolver;\n\nclass WheelEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'wheeling');\n  }\n  wheel(event) {\n    if (!this.state._active) this.start(event);\n    this.wheelChange(event);\n    this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));\n  }\n  wheelChange(event) {\n    const state = this.state;\n    state._delta = wheelValues(event);\n    _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);\n    clampStateInternalMovementToBounds(state);\n    this.compute(event);\n    this.emit();\n  }\n  wheelEnd() {\n    if (!this.state._active) return;\n    this.state._active = false;\n    this.compute();\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction('wheel', '', this.wheel.bind(this));\n  }\n}\n\nconst wheelConfigResolver = coordinatesConfigResolver;\n\nclass HoverEngine extends CoordinatesEngine {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"ingKey\", 'hovering');\n  }\n  enter(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    this.start(event);\n    this.computeValues(pointerValues(event));\n    this.compute(event);\n    this.emit();\n  }\n  leave(event) {\n    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n    const state = this.state;\n    if (!state._active) return;\n    state._active = false;\n    const values = pointerValues(event);\n    state._movement = state._delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(values, state._values);\n    this.computeValues(values);\n    this.compute(event);\n    state.delta = state.movement;\n    this.emit();\n  }\n  bind(bindFunction) {\n    bindFunction('pointer', 'enter', this.enter.bind(this));\n    bindFunction('pointer', 'leave', this.leave.bind(this));\n  }\n}\n\nconst hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: (value = true) => value\n});\n\nconst EngineMap = new Map();\nconst ConfigResolverMap = new Map();\nfunction registerAction(action) {\n  EngineMap.set(action.key, action.engine);\n  ConfigResolverMap.set(action.key, action.resolver);\n}\nconst dragAction = {\n  key: 'drag',\n  engine: DragEngine,\n  resolver: dragConfigResolver\n};\nconst hoverAction = {\n  key: 'hover',\n  engine: HoverEngine,\n  resolver: hoverConfigResolver\n};\nconst moveAction = {\n  key: 'move',\n  engine: MoveEngine,\n  resolver: moveConfigResolver\n};\nconst pinchAction = {\n  key: 'pinch',\n  engine: PinchEngine,\n  resolver: pinchConfigResolver\n};\nconst scrollAction = {\n  key: 'scroll',\n  engine: ScrollEngine,\n  resolver: scrollConfigResolver\n};\nconst wheelAction = {\n  key: 'wheel',\n  engine: WheelEngine,\n  resolver: wheelConfigResolver\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVzZS1nZXN0dXJlL2NvcmUvZGlzdC9hY3Rpb25zLTc2Yjg2ODNlLmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2R1Y3Rpb25wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0B1c2UtZ2VzdHVyZS9jb3JlL2Rpc3QvYWN0aW9ucy03NmI4NjgzZS5lc20uanM/ZGJiYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWLCBjIGFzIGNvbXB1dGVSdWJiZXJiYW5kIH0gZnJvbSAnLi9tYXRocy0wYWIzOWFlOS5lc20uanMnO1xuXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlcztcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG59XG5cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuY29uc3QgRVZFTlRfVFlQRV9NQVAgPSB7XG4gIHBvaW50ZXI6IHtcbiAgICBzdGFydDogJ2Rvd24nLFxuICAgIGNoYW5nZTogJ21vdmUnLFxuICAgIGVuZDogJ3VwJ1xuICB9LFxuICBtb3VzZToge1xuICAgIHN0YXJ0OiAnZG93bicsXG4gICAgY2hhbmdlOiAnbW92ZScsXG4gICAgZW5kOiAndXAnXG4gIH0sXG4gIHRvdWNoOiB7XG4gICAgc3RhcnQ6ICdzdGFydCcsXG4gICAgY2hhbmdlOiAnbW92ZScsXG4gICAgZW5kOiAnZW5kJ1xuICB9LFxuICBnZXN0dXJlOiB7XG4gICAgc3RhcnQ6ICdzdGFydCcsXG4gICAgY2hhbmdlOiAnY2hhbmdlJyxcbiAgICBlbmQ6ICdlbmQnXG4gIH1cbn07XG5mdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICBpZiAoIXN0cmluZykgcmV0dXJuICcnO1xuICByZXR1cm4gc3RyaW5nWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG59XG5jb25zdCBhY3Rpb25zV2l0aG91dENhcHR1cmVTdXBwb3J0ZWQgPSBbJ2VudGVyJywgJ2xlYXZlJ107XG5mdW5jdGlvbiBoYXNDYXB0dXJlKGNhcHR1cmUgPSBmYWxzZSwgYWN0aW9uS2V5KSB7XG4gIHJldHVybiBjYXB0dXJlICYmICFhY3Rpb25zV2l0aG91dENhcHR1cmVTdXBwb3J0ZWQuaW5jbHVkZXMoYWN0aW9uS2V5KTtcbn1cbmZ1bmN0aW9uIHRvSGFuZGxlclByb3AoZGV2aWNlLCBhY3Rpb24gPSAnJywgY2FwdHVyZSA9IGZhbHNlKSB7XG4gIGNvbnN0IGRldmljZVByb3BzID0gRVZFTlRfVFlQRV9NQVBbZGV2aWNlXTtcbiAgY29uc3QgYWN0aW9uS2V5ID0gZGV2aWNlUHJvcHMgPyBkZXZpY2VQcm9wc1thY3Rpb25dIHx8IGFjdGlvbiA6IGFjdGlvbjtcbiAgcmV0dXJuICdvbicgKyBjYXBpdGFsaXplKGRldmljZSkgKyBjYXBpdGFsaXplKGFjdGlvbktleSkgKyAoaGFzQ2FwdHVyZShjYXB0dXJlLCBhY3Rpb25LZXkpID8gJ0NhcHR1cmUnIDogJycpO1xufVxuY29uc3QgcG9pbnRlckNhcHR1cmVFdmVudHMgPSBbJ2dvdHBvaW50ZXJjYXB0dXJlJywgJ2xvc3Rwb2ludGVyY2FwdHVyZSddO1xuZnVuY3Rpb24gcGFyc2VQcm9wKHByb3ApIHtcbiAgbGV0IGV2ZW50S2V5ID0gcHJvcC5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKTtcbiAgY29uc3QgcGFzc2l2ZSA9ICEhfmV2ZW50S2V5LmluZGV4T2YoJ3Bhc3NpdmUnKTtcbiAgaWYgKHBhc3NpdmUpIGV2ZW50S2V5ID0gZXZlbnRLZXkucmVwbGFjZSgncGFzc2l2ZScsICcnKTtcbiAgY29uc3QgY2FwdHVyZUtleSA9IHBvaW50ZXJDYXB0dXJlRXZlbnRzLmluY2x1ZGVzKGV2ZW50S2V5KSA/ICdjYXB0dXJlY2FwdHVyZScgOiAnY2FwdHVyZSc7XG4gIGNvbnN0IGNhcHR1cmUgPSAhIX5ldmVudEtleS5pbmRleE9mKGNhcHR1cmVLZXkpO1xuICBpZiAoY2FwdHVyZSkgZXZlbnRLZXkgPSBldmVudEtleS5yZXBsYWNlKCdjYXB0dXJlJywgJycpO1xuICByZXR1cm4ge1xuICAgIGRldmljZTogZXZlbnRLZXksXG4gICAgY2FwdHVyZSxcbiAgICBwYXNzaXZlXG4gIH07XG59XG5mdW5jdGlvbiB0b0RvbUV2ZW50VHlwZShkZXZpY2UsIGFjdGlvbiA9ICcnKSB7XG4gIGNvbnN0IGRldmljZVByb3BzID0gRVZFTlRfVFlQRV9NQVBbZGV2aWNlXTtcbiAgY29uc3QgYWN0aW9uS2V5ID0gZGV2aWNlUHJvcHMgPyBkZXZpY2VQcm9wc1thY3Rpb25dIHx8IGFjdGlvbiA6IGFjdGlvbjtcbiAgcmV0dXJuIGRldmljZSArIGFjdGlvbktleTtcbn1cbmZ1bmN0aW9uIGlzVG91Y2goZXZlbnQpIHtcbiAgcmV0dXJuICd0b3VjaGVzJyBpbiBldmVudDtcbn1cbmZ1bmN0aW9uIGdldFBvaW50ZXJUeXBlKGV2ZW50KSB7XG4gIGlmIChpc1RvdWNoKGV2ZW50KSkgcmV0dXJuICd0b3VjaCc7XG4gIGlmICgncG9pbnRlclR5cGUnIGluIGV2ZW50KSByZXR1cm4gZXZlbnQucG9pbnRlclR5cGU7XG4gIHJldHVybiAnbW91c2UnO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFRhcmdldFRvdWNoTGlzdChldmVudCkge1xuICByZXR1cm4gQXJyYXkuZnJvbShldmVudC50b3VjaGVzKS5maWx0ZXIoZSA9PiB7XG4gICAgdmFyIF9ldmVudCRjdXJyZW50VGFyZ2V0LCBfZXZlbnQkY3VycmVudFRhcmdldCQ7XG4gICAgcmV0dXJuIGUudGFyZ2V0ID09PSBldmVudC5jdXJyZW50VGFyZ2V0IHx8ICgoX2V2ZW50JGN1cnJlbnRUYXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0KSA9PT0gbnVsbCB8fCBfZXZlbnQkY3VycmVudFRhcmdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9ldmVudCRjdXJyZW50VGFyZ2V0JCA9IF9ldmVudCRjdXJyZW50VGFyZ2V0LmNvbnRhaW5zKSA9PT0gbnVsbCB8fCBfZXZlbnQkY3VycmVudFRhcmdldCQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ldmVudCRjdXJyZW50VGFyZ2V0JC5jYWxsKF9ldmVudCRjdXJyZW50VGFyZ2V0LCBlLnRhcmdldCkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFRvdWNoTGlzdChldmVudCkge1xuICByZXR1cm4gZXZlbnQudHlwZSA9PT0gJ3RvdWNoZW5kJyB8fCBldmVudC50eXBlID09PSAndG91Y2hjYW5jZWwnID8gZXZlbnQuY2hhbmdlZFRvdWNoZXMgOiBldmVudC50YXJnZXRUb3VjaGVzO1xufVxuZnVuY3Rpb24gZ2V0VmFsdWVFdmVudChldmVudCkge1xuICByZXR1cm4gaXNUb3VjaChldmVudCkgPyBnZXRUb3VjaExpc3QoZXZlbnQpWzBdIDogZXZlbnQ7XG59XG5mdW5jdGlvbiBkaXN0YW5jZUFuZ2xlKFAxLCBQMikge1xuICB0cnkge1xuICAgIGNvbnN0IGR4ID0gUDIuY2xpZW50WCAtIFAxLmNsaWVudFg7XG4gICAgY29uc3QgZHkgPSBQMi5jbGllbnRZIC0gUDEuY2xpZW50WTtcbiAgICBjb25zdCBjeCA9IChQMi5jbGllbnRYICsgUDEuY2xpZW50WCkgLyAyO1xuICAgIGNvbnN0IGN5ID0gKFAyLmNsaWVudFkgKyBQMS5jbGllbnRZKSAvIDI7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLmh5cG90KGR4LCBkeSk7XG4gICAgY29uc3QgYW5nbGUgPSAtKE1hdGguYXRhbjIoZHgsIGR5KSAqIDE4MCkgLyBNYXRoLlBJO1xuICAgIGNvbnN0IG9yaWdpbiA9IFtjeCwgY3ldO1xuICAgIHJldHVybiB7XG4gICAgICBhbmdsZSxcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgb3JpZ2luXG4gICAgfTtcbiAgfSBjYXRjaCAoX3VudXNlZCkge31cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB0b3VjaElkcyhldmVudCkge1xuICByZXR1cm4gZ2V0Q3VycmVudFRhcmdldFRvdWNoTGlzdChldmVudCkubWFwKHRvdWNoID0+IHRvdWNoLmlkZW50aWZpZXIpO1xufVxuZnVuY3Rpb24gdG91Y2hEaXN0YW5jZUFuZ2xlKGV2ZW50LCBpZHMpIHtcbiAgY29uc3QgW1AxLCBQMl0gPSBBcnJheS5mcm9tKGV2ZW50LnRvdWNoZXMpLmZpbHRlcih0b3VjaCA9PiBpZHMuaW5jbHVkZXModG91Y2guaWRlbnRpZmllcikpO1xuICByZXR1cm4gZGlzdGFuY2VBbmdsZShQMSwgUDIpO1xufVxuZnVuY3Rpb24gcG9pbnRlcklkKGV2ZW50KSB7XG4gIGNvbnN0IHZhbHVlRXZlbnQgPSBnZXRWYWx1ZUV2ZW50KGV2ZW50KTtcbiAgcmV0dXJuIGlzVG91Y2goZXZlbnQpID8gdmFsdWVFdmVudC5pZGVudGlmaWVyIDogdmFsdWVFdmVudC5wb2ludGVySWQ7XG59XG5mdW5jdGlvbiBwb2ludGVyVmFsdWVzKGV2ZW50KSB7XG4gIGNvbnN0IHZhbHVlRXZlbnQgPSBnZXRWYWx1ZUV2ZW50KGV2ZW50KTtcbiAgcmV0dXJuIFt2YWx1ZUV2ZW50LmNsaWVudFgsIHZhbHVlRXZlbnQuY2xpZW50WV07XG59XG5jb25zdCBMSU5FX0hFSUdIVCA9IDQwO1xuY29uc3QgUEFHRV9IRUlHSFQgPSA4MDA7XG5mdW5jdGlvbiB3aGVlbFZhbHVlcyhldmVudCkge1xuICBsZXQge1xuICAgIGRlbHRhWCxcbiAgICBkZWx0YVksXG4gICAgZGVsdGFNb2RlXG4gIH0gPSBldmVudDtcbiAgaWYgKGRlbHRhTW9kZSA9PT0gMSkge1xuICAgIGRlbHRhWCAqPSBMSU5FX0hFSUdIVDtcbiAgICBkZWx0YVkgKj0gTElORV9IRUlHSFQ7XG4gIH0gZWxzZSBpZiAoZGVsdGFNb2RlID09PSAyKSB7XG4gICAgZGVsdGFYICo9IFBBR0VfSEVJR0hUO1xuICAgIGRlbHRhWSAqPSBQQUdFX0hFSUdIVDtcbiAgfVxuICByZXR1cm4gW2RlbHRhWCwgZGVsdGFZXTtcbn1cbmZ1bmN0aW9uIHNjcm9sbFZhbHVlcyhldmVudCkge1xuICB2YXIgX3JlZiwgX3JlZjI7XG4gIGNvbnN0IHtcbiAgICBzY3JvbGxYLFxuICAgIHNjcm9sbFksXG4gICAgc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3BcbiAgfSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gIHJldHVybiBbKF9yZWYgPSBzY3JvbGxYICE9PSBudWxsICYmIHNjcm9sbFggIT09IHZvaWQgMCA/IHNjcm9sbFggOiBzY3JvbGxMZWZ0KSAhPT0gbnVsbCAmJiBfcmVmICE9PSB2b2lkIDAgPyBfcmVmIDogMCwgKF9yZWYyID0gc2Nyb2xsWSAhPT0gbnVsbCAmJiBzY3JvbGxZICE9PSB2b2lkIDAgPyBzY3JvbGxZIDogc2Nyb2xsVG9wKSAhPT0gbnVsbCAmJiBfcmVmMiAhPT0gdm9pZCAwID8gX3JlZjIgOiAwXTtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50RGV0YWlscyhldmVudCkge1xuICBjb25zdCBwYXlsb2FkID0ge307XG4gIGlmICgnYnV0dG9ucycgaW4gZXZlbnQpIHBheWxvYWQuYnV0dG9ucyA9IGV2ZW50LmJ1dHRvbnM7XG4gIGlmICgnc2hpZnRLZXknIGluIGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgc2hpZnRLZXksXG4gICAgICBhbHRLZXksXG4gICAgICBtZXRhS2V5LFxuICAgICAgY3RybEtleVxuICAgIH0gPSBldmVudDtcbiAgICBPYmplY3QuYXNzaWduKHBheWxvYWQsIHtcbiAgICAgIHNoaWZ0S2V5LFxuICAgICAgYWx0S2V5LFxuICAgICAgbWV0YUtleSxcbiAgICAgIGN0cmxLZXlcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcGF5bG9hZDtcbn1cblxuZnVuY3Rpb24gY2FsbCh2LCAuLi5hcmdzKSB7XG4gIGlmICh0eXBlb2YgdiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2KC4uLmFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2O1xuICB9XG59XG5mdW5jdGlvbiBub29wKCkge31cbmZ1bmN0aW9uIGNoYWluKC4uLmZucykge1xuICBpZiAoZm5zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG5vb3A7XG4gIGlmIChmbnMubGVuZ3RoID09PSAxKSByZXR1cm4gZm5zWzBdO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGxldCByZXN1bHQ7XG4gICAgZm9yIChjb25zdCBmbiBvZiBmbnMpIHtcbiAgICAgIHJlc3VsdCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuZnVuY3Rpb24gYXNzaWduRGVmYXVsdCh2YWx1ZSwgZmFsbGJhY2spIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGZhbGxiYWNrLCB2YWx1ZSB8fCB7fSk7XG59XG5cbmNvbnN0IEJFRk9SRV9MQVNUX0tJTkVNQVRJQ1NfREVMQVkgPSAzMjtcbmNsYXNzIEVuZ2luZSB7XG4gIGNvbnN0cnVjdG9yKGN0cmwsIGFyZ3MsIGtleSkge1xuICAgIHRoaXMuY3RybCA9IGN0cmw7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICBpZiAoIXRoaXMuc3RhdGUpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSB7fTtcbiAgICAgIHRoaXMuY29tcHV0ZVZhbHVlcyhbMCwgMF0pO1xuICAgICAgdGhpcy5jb21wdXRlSW5pdGlhbCgpO1xuICAgICAgaWYgKHRoaXMuaW5pdCkgdGhpcy5pbml0KCk7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuICB9XG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jdHJsLnN0YXRlW3RoaXMua2V5XTtcbiAgfVxuICBzZXQgc3RhdGUoc3RhdGUpIHtcbiAgICB0aGlzLmN0cmwuc3RhdGVbdGhpcy5rZXldID0gc3RhdGU7XG4gIH1cbiAgZ2V0IHNoYXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdHJsLnN0YXRlLnNoYXJlZDtcbiAgfVxuICBnZXQgZXZlbnRTdG9yZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jdHJsLmdlc3R1cmVFdmVudFN0b3Jlc1t0aGlzLmtleV07XG4gIH1cbiAgZ2V0IHRpbWVvdXRTdG9yZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jdHJsLmdlc3R1cmVUaW1lb3V0U3RvcmVzW3RoaXMua2V5XTtcbiAgfVxuICBnZXQgY29uZmlnKCkge1xuICAgIHJldHVybiB0aGlzLmN0cmwuY29uZmlnW3RoaXMua2V5XTtcbiAgfVxuICBnZXQgc2hhcmVkQ29uZmlnKCkge1xuICAgIHJldHVybiB0aGlzLmN0cmwuY29uZmlnLnNoYXJlZDtcbiAgfVxuICBnZXQgaGFuZGxlcigpIHtcbiAgICByZXR1cm4gdGhpcy5jdHJsLmhhbmRsZXJzW3RoaXMua2V5XTtcbiAgfVxuICByZXNldCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGF0ZSxcbiAgICAgIHNoYXJlZCxcbiAgICAgIGluZ0tleSxcbiAgICAgIGFyZ3NcbiAgICB9ID0gdGhpcztcbiAgICBzaGFyZWRbaW5nS2V5XSA9IHN0YXRlLl9hY3RpdmUgPSBzdGF0ZS5hY3RpdmUgPSBzdGF0ZS5fYmxvY2tlZCA9IHN0YXRlLl9mb3JjZSA9IGZhbHNlO1xuICAgIHN0YXRlLl9zdGVwID0gW2ZhbHNlLCBmYWxzZV07XG4gICAgc3RhdGUuaW50ZW50aW9uYWwgPSBmYWxzZTtcbiAgICBzdGF0ZS5fbW92ZW1lbnQgPSBbMCwgMF07XG4gICAgc3RhdGUuX2Rpc3RhbmNlID0gWzAsIDBdO1xuICAgIHN0YXRlLl9kaXJlY3Rpb24gPSBbMCwgMF07XG4gICAgc3RhdGUuX2RlbHRhID0gWzAsIDBdO1xuICAgIHN0YXRlLl9ib3VuZHMgPSBbWy1JbmZpbml0eSwgSW5maW5pdHldLCBbLUluZmluaXR5LCBJbmZpbml0eV1dO1xuICAgIHN0YXRlLmFyZ3MgPSBhcmdzO1xuICAgIHN0YXRlLmF4aXMgPSB1bmRlZmluZWQ7XG4gICAgc3RhdGUubWVtbyA9IHVuZGVmaW5lZDtcbiAgICBzdGF0ZS5lbGFwc2VkVGltZSA9IHN0YXRlLnRpbWVEZWx0YSA9IDA7XG4gICAgc3RhdGUuZGlyZWN0aW9uID0gWzAsIDBdO1xuICAgIHN0YXRlLmRpc3RhbmNlID0gWzAsIDBdO1xuICAgIHN0YXRlLm92ZXJmbG93ID0gWzAsIDBdO1xuICAgIHN0YXRlLl9tb3ZlbWVudEJvdW5kID0gW2ZhbHNlLCBmYWxzZV07XG4gICAgc3RhdGUudmVsb2NpdHkgPSBbMCwgMF07XG4gICAgc3RhdGUubW92ZW1lbnQgPSBbMCwgMF07XG4gICAgc3RhdGUuZGVsdGEgPSBbMCwgMF07XG4gICAgc3RhdGUudGltZVN0YW1wID0gMDtcbiAgfVxuICBzdGFydChldmVudCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBpZiAoIXN0YXRlLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIHRoaXMuY29tcHV0ZUluaXRpYWwoKTtcbiAgICAgIHN0YXRlLl9hY3RpdmUgPSB0cnVlO1xuICAgICAgc3RhdGUudGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgc3RhdGUuY3VycmVudFRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICBzdGF0ZS5sYXN0T2Zmc2V0ID0gY29uZmlnLmZyb20gPyBjYWxsKGNvbmZpZy5mcm9tLCBzdGF0ZSkgOiBzdGF0ZS5vZmZzZXQ7XG4gICAgICBzdGF0ZS5vZmZzZXQgPSBzdGF0ZS5sYXN0T2Zmc2V0O1xuICAgICAgc3RhdGUuc3RhcnRUaW1lID0gc3RhdGUudGltZVN0YW1wID0gZXZlbnQudGltZVN0YW1wO1xuICAgIH1cbiAgfVxuICBjb21wdXRlVmFsdWVzKHZhbHVlcykge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBzdGF0ZS5fdmFsdWVzID0gdmFsdWVzO1xuICAgIHN0YXRlLnZhbHVlcyA9IHRoaXMuY29uZmlnLnRyYW5zZm9ybSh2YWx1ZXMpO1xuICB9XG4gIGNvbXB1dGVJbml0aWFsKCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBzdGF0ZS5faW5pdGlhbCA9IHN0YXRlLl92YWx1ZXM7XG4gICAgc3RhdGUuaW5pdGlhbCA9IHN0YXRlLnZhbHVlcztcbiAgfVxuICBjb21wdXRlKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RhdGUsXG4gICAgICBjb25maWcsXG4gICAgICBzaGFyZWRcbiAgICB9ID0gdGhpcztcbiAgICBzdGF0ZS5hcmdzID0gdGhpcy5hcmdzO1xuICAgIGxldCBkdCA9IDA7XG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICBzdGF0ZS5ldmVudCA9IGV2ZW50O1xuICAgICAgaWYgKGNvbmZpZy5wcmV2ZW50RGVmYXVsdCAmJiBldmVudC5jYW5jZWxhYmxlKSBzdGF0ZS5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgc3RhdGUudHlwZSA9IGV2ZW50LnR5cGU7XG4gICAgICBzaGFyZWQudG91Y2hlcyA9IHRoaXMuY3RybC5wb2ludGVySWRzLnNpemUgfHwgdGhpcy5jdHJsLnRvdWNoSWRzLnNpemU7XG4gICAgICBzaGFyZWQubG9ja2VkID0gISFkb2N1bWVudC5wb2ludGVyTG9ja0VsZW1lbnQ7XG4gICAgICBPYmplY3QuYXNzaWduKHNoYXJlZCwgZ2V0RXZlbnREZXRhaWxzKGV2ZW50KSk7XG4gICAgICBzaGFyZWQuZG93biA9IHNoYXJlZC5wcmVzc2VkID0gc2hhcmVkLmJ1dHRvbnMgJSAyID09PSAxIHx8IHNoYXJlZC50b3VjaGVzID4gMDtcbiAgICAgIGR0ID0gZXZlbnQudGltZVN0YW1wIC0gc3RhdGUudGltZVN0YW1wO1xuICAgICAgc3RhdGUudGltZVN0YW1wID0gZXZlbnQudGltZVN0YW1wO1xuICAgICAgc3RhdGUuZWxhcHNlZFRpbWUgPSBzdGF0ZS50aW1lU3RhbXAgLSBzdGF0ZS5zdGFydFRpbWU7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5fYWN0aXZlKSB7XG4gICAgICBjb25zdCBfYWJzb2x1dGVEZWx0YSA9IHN0YXRlLl9kZWx0YS5tYXAoTWF0aC5hYnMpO1xuICAgICAgVi5hZGRUbyhzdGF0ZS5fZGlzdGFuY2UsIF9hYnNvbHV0ZURlbHRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXhpc0ludGVudCkgdGhpcy5heGlzSW50ZW50KGV2ZW50KTtcbiAgICBjb25zdCBbX20wLCBfbTFdID0gc3RhdGUuX21vdmVtZW50O1xuICAgIGNvbnN0IFt0MCwgdDFdID0gY29uZmlnLnRocmVzaG9sZDtcbiAgICBjb25zdCB7XG4gICAgICBfc3RlcCxcbiAgICAgIHZhbHVlc1xuICAgIH0gPSBzdGF0ZTtcbiAgICBpZiAoY29uZmlnLmhhc0N1c3RvbVRyYW5zZm9ybSkge1xuICAgICAgaWYgKF9zdGVwWzBdID09PSBmYWxzZSkgX3N0ZXBbMF0gPSBNYXRoLmFicyhfbTApID49IHQwICYmIHZhbHVlc1swXTtcbiAgICAgIGlmIChfc3RlcFsxXSA9PT0gZmFsc2UpIF9zdGVwWzFdID0gTWF0aC5hYnMoX20xKSA+PSB0MSAmJiB2YWx1ZXNbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChfc3RlcFswXSA9PT0gZmFsc2UpIF9zdGVwWzBdID0gTWF0aC5hYnMoX20wKSA+PSB0MCAmJiBNYXRoLnNpZ24oX20wKSAqIHQwO1xuICAgICAgaWYgKF9zdGVwWzFdID09PSBmYWxzZSkgX3N0ZXBbMV0gPSBNYXRoLmFicyhfbTEpID49IHQxICYmIE1hdGguc2lnbihfbTEpICogdDE7XG4gICAgfVxuICAgIHN0YXRlLmludGVudGlvbmFsID0gX3N0ZXBbMF0gIT09IGZhbHNlIHx8IF9zdGVwWzFdICE9PSBmYWxzZTtcbiAgICBpZiAoIXN0YXRlLmludGVudGlvbmFsKSByZXR1cm47XG4gICAgY29uc3QgbW92ZW1lbnQgPSBbMCwgMF07XG4gICAgaWYgKGNvbmZpZy5oYXNDdXN0b21UcmFuc2Zvcm0pIHtcbiAgICAgIGNvbnN0IFt2MCwgdjFdID0gdmFsdWVzO1xuICAgICAgbW92ZW1lbnRbMF0gPSBfc3RlcFswXSAhPT0gZmFsc2UgPyB2MCAtIF9zdGVwWzBdIDogMDtcbiAgICAgIG1vdmVtZW50WzFdID0gX3N0ZXBbMV0gIT09IGZhbHNlID8gdjEgLSBfc3RlcFsxXSA6IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vdmVtZW50WzBdID0gX3N0ZXBbMF0gIT09IGZhbHNlID8gX20wIC0gX3N0ZXBbMF0gOiAwO1xuICAgICAgbW92ZW1lbnRbMV0gPSBfc3RlcFsxXSAhPT0gZmFsc2UgPyBfbTEgLSBfc3RlcFsxXSA6IDA7XG4gICAgfVxuICAgIGlmICh0aGlzLnJlc3RyaWN0VG9BeGlzICYmICFzdGF0ZS5fYmxvY2tlZCkgdGhpcy5yZXN0cmljdFRvQXhpcyhtb3ZlbWVudCk7XG4gICAgY29uc3QgcHJldmlvdXNPZmZzZXQgPSBzdGF0ZS5vZmZzZXQ7XG4gICAgY29uc3QgZ2VzdHVyZUlzQWN0aXZlID0gc3RhdGUuX2FjdGl2ZSAmJiAhc3RhdGUuX2Jsb2NrZWQgfHwgc3RhdGUuYWN0aXZlO1xuICAgIGlmIChnZXN0dXJlSXNBY3RpdmUpIHtcbiAgICAgIHN0YXRlLmZpcnN0ID0gc3RhdGUuX2FjdGl2ZSAmJiAhc3RhdGUuYWN0aXZlO1xuICAgICAgc3RhdGUubGFzdCA9ICFzdGF0ZS5fYWN0aXZlICYmIHN0YXRlLmFjdGl2ZTtcbiAgICAgIHN0YXRlLmFjdGl2ZSA9IHNoYXJlZFt0aGlzLmluZ0tleV0gPSBzdGF0ZS5fYWN0aXZlO1xuICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIGlmIChzdGF0ZS5maXJzdCkge1xuICAgICAgICAgIGlmICgnYm91bmRzJyBpbiBjb25maWcpIHN0YXRlLl9ib3VuZHMgPSBjYWxsKGNvbmZpZy5ib3VuZHMsIHN0YXRlKTtcbiAgICAgICAgICBpZiAodGhpcy5zZXR1cCkgdGhpcy5zZXR1cCgpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vdmVtZW50ID0gbW92ZW1lbnQ7XG4gICAgICAgIHRoaXMuY29tcHV0ZU9mZnNldCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBbb3gsIG95XSA9IHN0YXRlLm9mZnNldDtcbiAgICBjb25zdCBbW3gwLCB4MV0sIFt5MCwgeTFdXSA9IHN0YXRlLl9ib3VuZHM7XG4gICAgc3RhdGUub3ZlcmZsb3cgPSBbb3ggPCB4MCA/IC0xIDogb3ggPiB4MSA/IDEgOiAwLCBveSA8IHkwID8gLTEgOiBveSA+IHkxID8gMSA6IDBdO1xuICAgIHN0YXRlLl9tb3ZlbWVudEJvdW5kWzBdID0gc3RhdGUub3ZlcmZsb3dbMF0gPyBzdGF0ZS5fbW92ZW1lbnRCb3VuZFswXSA9PT0gZmFsc2UgPyBzdGF0ZS5fbW92ZW1lbnRbMF0gOiBzdGF0ZS5fbW92ZW1lbnRCb3VuZFswXSA6IGZhbHNlO1xuICAgIHN0YXRlLl9tb3ZlbWVudEJvdW5kWzFdID0gc3RhdGUub3ZlcmZsb3dbMV0gPyBzdGF0ZS5fbW92ZW1lbnRCb3VuZFsxXSA9PT0gZmFsc2UgPyBzdGF0ZS5fbW92ZW1lbnRbMV0gOiBzdGF0ZS5fbW92ZW1lbnRCb3VuZFsxXSA6IGZhbHNlO1xuICAgIGNvbnN0IHJ1YmJlcmJhbmQgPSBzdGF0ZS5fYWN0aXZlID8gY29uZmlnLnJ1YmJlcmJhbmQgfHwgWzAsIDBdIDogWzAsIDBdO1xuICAgIHN0YXRlLm9mZnNldCA9IGNvbXB1dGVSdWJiZXJiYW5kKHN0YXRlLl9ib3VuZHMsIHN0YXRlLm9mZnNldCwgcnViYmVyYmFuZCk7XG4gICAgc3RhdGUuZGVsdGEgPSBWLnN1YihzdGF0ZS5vZmZzZXQsIHByZXZpb3VzT2Zmc2V0KTtcbiAgICB0aGlzLmNvbXB1dGVNb3ZlbWVudCgpO1xuICAgIGlmIChnZXN0dXJlSXNBY3RpdmUgJiYgKCFzdGF0ZS5sYXN0IHx8IGR0ID4gQkVGT1JFX0xBU1RfS0lORU1BVElDU19ERUxBWSkpIHtcbiAgICAgIHN0YXRlLmRlbHRhID0gVi5zdWIoc3RhdGUub2Zmc2V0LCBwcmV2aW91c09mZnNldCk7XG4gICAgICBjb25zdCBhYnNvbHV0ZURlbHRhID0gc3RhdGUuZGVsdGEubWFwKE1hdGguYWJzKTtcbiAgICAgIFYuYWRkVG8oc3RhdGUuZGlzdGFuY2UsIGFic29sdXRlRGVsdGEpO1xuICAgICAgc3RhdGUuZGlyZWN0aW9uID0gc3RhdGUuZGVsdGEubWFwKE1hdGguc2lnbik7XG4gICAgICBzdGF0ZS5fZGlyZWN0aW9uID0gc3RhdGUuX2RlbHRhLm1hcChNYXRoLnNpZ24pO1xuICAgICAgaWYgKCFzdGF0ZS5maXJzdCAmJiBkdCA+IDApIHtcbiAgICAgICAgc3RhdGUudmVsb2NpdHkgPSBbYWJzb2x1dGVEZWx0YVswXSAvIGR0LCBhYnNvbHV0ZURlbHRhWzFdIC8gZHRdO1xuICAgICAgICBzdGF0ZS50aW1lRGVsdGEgPSBkdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZW1pdCgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2hhcmVkID0gdGhpcy5zaGFyZWQ7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgaWYgKCFzdGF0ZS5fYWN0aXZlKSB0aGlzLmNsZWFuKCk7XG4gICAgaWYgKChzdGF0ZS5fYmxvY2tlZCB8fCAhc3RhdGUuaW50ZW50aW9uYWwpICYmICFzdGF0ZS5fZm9yY2UgJiYgIWNvbmZpZy50cmlnZ2VyQWxsRXZlbnRzKSByZXR1cm47XG4gICAgY29uc3QgbWVtbyA9IHRoaXMuaGFuZGxlcihfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgc2hhcmVkKSwgc3RhdGUpLCB7fSwge1xuICAgICAgW3RoaXMuYWxpYXNLZXldOiBzdGF0ZS52YWx1ZXNcbiAgICB9KSk7XG4gICAgaWYgKG1lbW8gIT09IHVuZGVmaW5lZCkgc3RhdGUubWVtbyA9IG1lbW87XG4gIH1cbiAgY2xlYW4oKSB7XG4gICAgdGhpcy5ldmVudFN0b3JlLmNsZWFuKCk7XG4gICAgdGhpcy50aW1lb3V0U3RvcmUuY2xlYW4oKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZWxlY3RBeGlzKFtkeCwgZHldLCB0aHJlc2hvbGQpIHtcbiAgY29uc3QgYWJzRHggPSBNYXRoLmFicyhkeCk7XG4gIGNvbnN0IGFic0R5ID0gTWF0aC5hYnMoZHkpO1xuICBpZiAoYWJzRHggPiBhYnNEeSAmJiBhYnNEeCA+IHRocmVzaG9sZCkge1xuICAgIHJldHVybiAneCc7XG4gIH1cbiAgaWYgKGFic0R5ID4gYWJzRHggJiYgYWJzRHkgPiB0aHJlc2hvbGQpIHtcbiAgICByZXR1cm4gJ3knO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5jbGFzcyBDb29yZGluYXRlc0VuZ2luZSBleHRlbmRzIEVuZ2luZSB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJhbGlhc0tleVwiLCAneHknKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICBzdXBlci5yZXNldCgpO1xuICAgIHRoaXMuc3RhdGUuYXhpcyA9IHVuZGVmaW5lZDtcbiAgfVxuICBpbml0KCkge1xuICAgIHRoaXMuc3RhdGUub2Zmc2V0ID0gWzAsIDBdO1xuICAgIHRoaXMuc3RhdGUubGFzdE9mZnNldCA9IFswLCAwXTtcbiAgfVxuICBjb21wdXRlT2Zmc2V0KCkge1xuICAgIHRoaXMuc3RhdGUub2Zmc2V0ID0gVi5hZGQodGhpcy5zdGF0ZS5sYXN0T2Zmc2V0LCB0aGlzLnN0YXRlLm1vdmVtZW50KTtcbiAgfVxuICBjb21wdXRlTW92ZW1lbnQoKSB7XG4gICAgdGhpcy5zdGF0ZS5tb3ZlbWVudCA9IFYuc3ViKHRoaXMuc3RhdGUub2Zmc2V0LCB0aGlzLnN0YXRlLmxhc3RPZmZzZXQpO1xuICB9XG4gIGF4aXNJbnRlbnQoZXZlbnQpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgaWYgKCFzdGF0ZS5heGlzICYmIGV2ZW50KSB7XG4gICAgICBjb25zdCB0aHJlc2hvbGQgPSB0eXBlb2YgY29uZmlnLmF4aXNUaHJlc2hvbGQgPT09ICdvYmplY3QnID8gY29uZmlnLmF4aXNUaHJlc2hvbGRbZ2V0UG9pbnRlclR5cGUoZXZlbnQpXSA6IGNvbmZpZy5heGlzVGhyZXNob2xkO1xuICAgICAgc3RhdGUuYXhpcyA9IHNlbGVjdEF4aXMoc3RhdGUuX21vdmVtZW50LCB0aHJlc2hvbGQpO1xuICAgIH1cbiAgICBzdGF0ZS5fYmxvY2tlZCA9IChjb25maWcubG9ja0RpcmVjdGlvbiB8fCAhIWNvbmZpZy5heGlzKSAmJiAhc3RhdGUuYXhpcyB8fCAhIWNvbmZpZy5heGlzICYmIGNvbmZpZy5heGlzICE9PSBzdGF0ZS5heGlzO1xuICB9XG4gIHJlc3RyaWN0VG9BeGlzKHYpIHtcbiAgICBpZiAodGhpcy5jb25maWcuYXhpcyB8fCB0aGlzLmNvbmZpZy5sb2NrRGlyZWN0aW9uKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUuYXhpcykge1xuICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICB2WzFdID0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAneSc6XG4gICAgICAgICAgdlswXSA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGlkZW50aXR5ID0gdiA9PiB2O1xuY29uc3QgREVGQVVMVF9SVUJCRVJCQU5EID0gMC4xNTtcbmNvbnN0IGNvbW1vbkNvbmZpZ1Jlc29sdmVyID0ge1xuICBlbmFibGVkKHZhbHVlID0gdHJ1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgZXZlbnRPcHRpb25zKHZhbHVlLCBfaywgY29uZmlnKSB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjb25maWcuc2hhcmVkLmV2ZW50T3B0aW9ucyksIHZhbHVlKTtcbiAgfSxcbiAgcHJldmVudERlZmF1bHQodmFsdWUgPSBmYWxzZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgdHJpZ2dlckFsbEV2ZW50cyh2YWx1ZSA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBydWJiZXJiYW5kKHZhbHVlID0gMCkge1xuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAgcmV0dXJuIFtERUZBVUxUX1JVQkJFUkJBTkQsIERFRkFVTFRfUlVCQkVSQkFORF07XG4gICAgICBjYXNlIGZhbHNlOlxuICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFYudG9WZWN0b3IodmFsdWUpO1xuICAgIH1cbiAgfSxcbiAgZnJvbSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHJldHVybiB2YWx1ZTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkgcmV0dXJuIFYudG9WZWN0b3IodmFsdWUpO1xuICB9LFxuICB0cmFuc2Zvcm0odmFsdWUsIF9rLCBjb25maWcpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSB2YWx1ZSB8fCBjb25maWcuc2hhcmVkLnRyYW5zZm9ybTtcbiAgICB0aGlzLmhhc0N1c3RvbVRyYW5zZm9ybSA9ICEhdHJhbnNmb3JtO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgY29uc3Qgb3JpZ2luYWxUcmFuc2Zvcm0gPSB0cmFuc2Zvcm0gfHwgaWRlbnRpdHk7XG4gICAgICByZXR1cm4gdiA9PiB7XG4gICAgICAgIGNvbnN0IHIgPSBvcmlnaW5hbFRyYW5zZm9ybSh2KTtcbiAgICAgICAgaWYgKCFpc0Zpbml0ZShyWzBdKSB8fCAhaXNGaW5pdGUoclsxXSkpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYFtAdXNlLWdlc3R1cmVdOiBjb25maWcudHJhbnNmb3JtKCkgbXVzdCBwcm9kdWNlIGEgdmFsaWQgcmVzdWx0LCBidXQgaXQgd2FzOiBbJHtyWzBdfSwke1sxXX1dYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNmb3JtIHx8IGlkZW50aXR5O1xuICB9LFxuICB0aHJlc2hvbGQodmFsdWUpIHtcbiAgICByZXR1cm4gVi50b1ZlY3Rvcih2YWx1ZSwgMCk7XG4gIH1cbn07XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgT2JqZWN0LmFzc2lnbihjb21tb25Db25maWdSZXNvbHZlciwge1xuICAgIGRvbVRhcmdldCh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFtAdXNlLWdlc3R1cmVdOiBcXGBkb21UYXJnZXRcXGAgb3B0aW9uIGhhcyBiZWVuIHJlbmFtZWQgdG8gXFxgdGFyZ2V0XFxgLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9LFxuICAgIGxvY2tEaXJlY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBbQHVzZS1nZXN0dXJlXTogXFxgbG9ja0RpcmVjdGlvblxcYCBvcHRpb24gaGFzIGJlZW4gbWVyZ2VkIHdpdGggXFxgYXhpc1xcYC4gVXNlIGl0IGFzIGluIFxcYHsgYXhpczogJ2xvY2snIH1cXGBgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBOYU47XG4gICAgfSxcbiAgICBpbml0aWFsKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBFcnJvcihgW0B1c2UtZ2VzdHVyZV06IFxcYGluaXRpYWxcXGAgb3B0aW9uIGhhcyBiZWVuIHJlbmFtZWQgdG8gXFxgZnJvbVxcYC5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICB9KTtcbn1cblxuY29uc3QgREVGQVVMVF9BWElTX1RIUkVTSE9MRCA9IDA7XG5jb25zdCBjb29yZGluYXRlc0NvbmZpZ1Jlc29sdmVyID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNvbW1vbkNvbmZpZ1Jlc29sdmVyKSwge30sIHtcbiAgYXhpcyhfdiwgX2ssIHtcbiAgICBheGlzXG4gIH0pIHtcbiAgICB0aGlzLmxvY2tEaXJlY3Rpb24gPSBheGlzID09PSAnbG9jayc7XG4gICAgaWYgKCF0aGlzLmxvY2tEaXJlY3Rpb24pIHJldHVybiBheGlzO1xuICB9LFxuICBheGlzVGhyZXNob2xkKHZhbHVlID0gREVGQVVMVF9BWElTX1RIUkVTSE9MRCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgYm91bmRzKHZhbHVlID0ge30pIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gc3RhdGUgPT4gY29vcmRpbmF0ZXNDb25maWdSZXNvbHZlci5ib3VuZHModmFsdWUoc3RhdGUpKTtcbiAgICB9XG4gICAgaWYgKCdjdXJyZW50JyBpbiB2YWx1ZSkge1xuICAgICAgcmV0dXJuICgpID0+IHZhbHVlLmN1cnJlbnQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICdmdW5jdGlvbicgJiYgdmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBsZWZ0ID0gLUluZmluaXR5LFxuICAgICAgcmlnaHQgPSBJbmZpbml0eSxcbiAgICAgIHRvcCA9IC1JbmZpbml0eSxcbiAgICAgIGJvdHRvbSA9IEluZmluaXR5XG4gICAgfSA9IHZhbHVlO1xuICAgIHJldHVybiBbW2xlZnQsIHJpZ2h0XSwgW3RvcCwgYm90dG9tXV07XG4gIH1cbn0pO1xuXG5jb25zdCBLRVlTX0RFTFRBX01BUCA9IHtcbiAgQXJyb3dSaWdodDogKGRpc3BsYWNlbWVudCwgZmFjdG9yID0gMSkgPT4gW2Rpc3BsYWNlbWVudCAqIGZhY3RvciwgMF0sXG4gIEFycm93TGVmdDogKGRpc3BsYWNlbWVudCwgZmFjdG9yID0gMSkgPT4gWy0xICogZGlzcGxhY2VtZW50ICogZmFjdG9yLCAwXSxcbiAgQXJyb3dVcDogKGRpc3BsYWNlbWVudCwgZmFjdG9yID0gMSkgPT4gWzAsIC0xICogZGlzcGxhY2VtZW50ICogZmFjdG9yXSxcbiAgQXJyb3dEb3duOiAoZGlzcGxhY2VtZW50LCBmYWN0b3IgPSAxKSA9PiBbMCwgZGlzcGxhY2VtZW50ICogZmFjdG9yXVxufTtcbmNsYXNzIERyYWdFbmdpbmUgZXh0ZW5kcyBDb29yZGluYXRlc0VuZ2luZSB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmdLZXlcIiwgJ2RyYWdnaW5nJyk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgc3VwZXIucmVzZXQoKTtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgc3RhdGUuX3BvaW50ZXJJZCA9IHVuZGVmaW5lZDtcbiAgICBzdGF0ZS5fcG9pbnRlckFjdGl2ZSA9IGZhbHNlO1xuICAgIHN0YXRlLl9rZXlib2FyZEFjdGl2ZSA9IGZhbHNlO1xuICAgIHN0YXRlLl9wcmV2ZW50U2Nyb2xsID0gZmFsc2U7XG4gICAgc3RhdGUuX2RlbGF5ZWQgPSBmYWxzZTtcbiAgICBzdGF0ZS5zd2lwZSA9IFswLCAwXTtcbiAgICBzdGF0ZS50YXAgPSBmYWxzZTtcbiAgICBzdGF0ZS5jYW5jZWxlZCA9IGZhbHNlO1xuICAgIHN0YXRlLmNhbmNlbCA9IHRoaXMuY2FuY2VsLmJpbmQodGhpcyk7XG4gIH1cbiAgc2V0dXAoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmIChzdGF0ZS5fYm91bmRzIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGJvdW5kUmVjdCA9IHN0YXRlLl9ib3VuZHMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCB0YXJnZXRSZWN0ID0gc3RhdGUuY3VycmVudFRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IF9ib3VuZHMgPSB7XG4gICAgICAgIGxlZnQ6IGJvdW5kUmVjdC5sZWZ0IC0gdGFyZ2V0UmVjdC5sZWZ0ICsgc3RhdGUub2Zmc2V0WzBdLFxuICAgICAgICByaWdodDogYm91bmRSZWN0LnJpZ2h0IC0gdGFyZ2V0UmVjdC5yaWdodCArIHN0YXRlLm9mZnNldFswXSxcbiAgICAgICAgdG9wOiBib3VuZFJlY3QudG9wIC0gdGFyZ2V0UmVjdC50b3AgKyBzdGF0ZS5vZmZzZXRbMV0sXG4gICAgICAgIGJvdHRvbTogYm91bmRSZWN0LmJvdHRvbSAtIHRhcmdldFJlY3QuYm90dG9tICsgc3RhdGUub2Zmc2V0WzFdXG4gICAgICB9O1xuICAgICAgc3RhdGUuX2JvdW5kcyA9IGNvb3JkaW5hdGVzQ29uZmlnUmVzb2x2ZXIuYm91bmRzKF9ib3VuZHMpO1xuICAgIH1cbiAgfVxuICBjYW5jZWwoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmIChzdGF0ZS5jYW5jZWxlZCkgcmV0dXJuO1xuICAgIHN0YXRlLmNhbmNlbGVkID0gdHJ1ZTtcbiAgICBzdGF0ZS5fYWN0aXZlID0gZmFsc2U7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmNvbXB1dGUoKTtcbiAgICAgIHRoaXMuZW1pdCgpO1xuICAgIH0sIDApO1xuICB9XG4gIHNldEFjdGl2ZSgpIHtcbiAgICB0aGlzLnN0YXRlLl9hY3RpdmUgPSB0aGlzLnN0YXRlLl9wb2ludGVyQWN0aXZlIHx8IHRoaXMuc3RhdGUuX2tleWJvYXJkQWN0aXZlO1xuICB9XG4gIGNsZWFuKCkge1xuICAgIHRoaXMucG9pbnRlckNsZWFuKCk7XG4gICAgdGhpcy5zdGF0ZS5fcG9pbnRlckFjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuc3RhdGUuX2tleWJvYXJkQWN0aXZlID0gZmFsc2U7XG4gICAgc3VwZXIuY2xlYW4oKTtcbiAgfVxuICBwb2ludGVyRG93bihldmVudCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoZXZlbnQuYnV0dG9ucyAhPSBudWxsICYmIChBcnJheS5pc0FycmF5KGNvbmZpZy5wb2ludGVyQnV0dG9ucykgPyAhY29uZmlnLnBvaW50ZXJCdXR0b25zLmluY2x1ZGVzKGV2ZW50LmJ1dHRvbnMpIDogY29uZmlnLnBvaW50ZXJCdXR0b25zICE9PSAtMSAmJiBjb25maWcucG9pbnRlckJ1dHRvbnMgIT09IGV2ZW50LmJ1dHRvbnMpKSByZXR1cm47XG4gICAgY29uc3QgY3RybElkcyA9IHRoaXMuY3RybC5zZXRFdmVudElkcyhldmVudCk7XG4gICAgaWYgKGNvbmZpZy5wb2ludGVyQ2FwdHVyZSkge1xuICAgICAgZXZlbnQudGFyZ2V0LnNldFBvaW50ZXJDYXB0dXJlKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgfVxuICAgIGlmIChjdHJsSWRzICYmIGN0cmxJZHMuc2l6ZSA+IDEgJiYgc3RhdGUuX3BvaW50ZXJBY3RpdmUpIHJldHVybjtcbiAgICB0aGlzLnN0YXJ0KGV2ZW50KTtcbiAgICB0aGlzLnNldHVwUG9pbnRlcihldmVudCk7XG4gICAgc3RhdGUuX3BvaW50ZXJJZCA9IHBvaW50ZXJJZChldmVudCk7XG4gICAgc3RhdGUuX3BvaW50ZXJBY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuY29tcHV0ZVZhbHVlcyhwb2ludGVyVmFsdWVzKGV2ZW50KSk7XG4gICAgdGhpcy5jb21wdXRlSW5pdGlhbCgpO1xuICAgIGlmIChjb25maWcucHJldmVudFNjcm9sbEF4aXMgJiYgZ2V0UG9pbnRlclR5cGUoZXZlbnQpICE9PSAnbW91c2UnKSB7XG4gICAgICBzdGF0ZS5fYWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLnNldHVwU2Nyb2xsUHJldmVudGlvbihldmVudCk7XG4gICAgfSBlbHNlIGlmIChjb25maWcuZGVsYXkgPiAwKSB7XG4gICAgICB0aGlzLnNldHVwRGVsYXlUcmlnZ2VyKGV2ZW50KTtcbiAgICAgIGlmIChjb25maWcudHJpZ2dlckFsbEV2ZW50cykge1xuICAgICAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgICAgICB0aGlzLmVtaXQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGFydFBvaW50ZXJEcmFnKGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgc3RhcnRQb2ludGVyRHJhZyhldmVudCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBzdGF0ZS5fYWN0aXZlID0gdHJ1ZTtcbiAgICBzdGF0ZS5fcHJldmVudFNjcm9sbCA9IHRydWU7XG4gICAgc3RhdGUuX2RlbGF5ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIHBvaW50ZXJNb3ZlKGV2ZW50KSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGlmICghc3RhdGUuX3BvaW50ZXJBY3RpdmUpIHJldHVybjtcbiAgICBjb25zdCBpZCA9IHBvaW50ZXJJZChldmVudCk7XG4gICAgaWYgKHN0YXRlLl9wb2ludGVySWQgIT09IHVuZGVmaW5lZCAmJiBpZCAhPT0gc3RhdGUuX3BvaW50ZXJJZCkgcmV0dXJuO1xuICAgIGNvbnN0IF92YWx1ZXMgPSBwb2ludGVyVmFsdWVzKGV2ZW50KTtcbiAgICBpZiAoZG9jdW1lbnQucG9pbnRlckxvY2tFbGVtZW50ID09PSBldmVudC50YXJnZXQpIHtcbiAgICAgIHN0YXRlLl9kZWx0YSA9IFtldmVudC5tb3ZlbWVudFgsIGV2ZW50Lm1vdmVtZW50WV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLl9kZWx0YSA9IFYuc3ViKF92YWx1ZXMsIHN0YXRlLl92YWx1ZXMpO1xuICAgICAgdGhpcy5jb21wdXRlVmFsdWVzKF92YWx1ZXMpO1xuICAgIH1cbiAgICBWLmFkZFRvKHN0YXRlLl9tb3ZlbWVudCwgc3RhdGUuX2RlbHRhKTtcbiAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgIGlmIChzdGF0ZS5fZGVsYXllZCAmJiBzdGF0ZS5pbnRlbnRpb25hbCkge1xuICAgICAgdGhpcy50aW1lb3V0U3RvcmUucmVtb3ZlKCdkcmFnRGVsYXknKTtcbiAgICAgIHN0YXRlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5zdGFydFBvaW50ZXJEcmFnKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5wcmV2ZW50U2Nyb2xsQXhpcyAmJiAhc3RhdGUuX3ByZXZlbnRTY3JvbGwpIHtcbiAgICAgIGlmIChzdGF0ZS5heGlzKSB7XG4gICAgICAgIGlmIChzdGF0ZS5heGlzID09PSBjb25maWcucHJldmVudFNjcm9sbEF4aXMgfHwgY29uZmlnLnByZXZlbnRTY3JvbGxBeGlzID09PSAneHknKSB7XG4gICAgICAgICAgc3RhdGUuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuY2xlYW4oKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50aW1lb3V0U3RvcmUucmVtb3ZlKCdzdGFydFBvaW50ZXJEcmFnJyk7XG4gICAgICAgICAgdGhpcy5zdGFydFBvaW50ZXJEcmFnKGV2ZW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgcG9pbnRlclVwKGV2ZW50KSB7XG4gICAgdGhpcy5jdHJsLnNldEV2ZW50SWRzKGV2ZW50KTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuY29uZmlnLnBvaW50ZXJDYXB0dXJlICYmIGV2ZW50LnRhcmdldC5oYXNQb2ludGVyQ2FwdHVyZShldmVudC5wb2ludGVySWQpKSB7XG4gICAgICAgIDtcbiAgICAgICAgZXZlbnQudGFyZ2V0LnJlbGVhc2VQb2ludGVyQ2FwdHVyZShldmVudC5wb2ludGVySWQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBjb25zb2xlLndhcm4oYFtAdXNlLWdlc3R1cmVdOiBJZiB5b3Ugc2VlIHRoaXMgbWVzc2FnZSwgaXQncyBsaWtlbHkgdGhhdCB5b3UncmUgdXNpbmcgYW4gb3V0ZGF0ZWQgdmVyc2lvbiBvZiBcXGBAcmVhY3QtdGhyZWUvZmliZXJcXGAuIFxcblxcblBsZWFzZSB1cGdyYWRlIHRvIHRoZSBsYXRlc3QgdmVyc2lvbi5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGlmICghc3RhdGUuX2FjdGl2ZSB8fCAhc3RhdGUuX3BvaW50ZXJBY3RpdmUpIHJldHVybjtcbiAgICBjb25zdCBpZCA9IHBvaW50ZXJJZChldmVudCk7XG4gICAgaWYgKHN0YXRlLl9wb2ludGVySWQgIT09IHVuZGVmaW5lZCAmJiBpZCAhPT0gc3RhdGUuX3BvaW50ZXJJZCkgcmV0dXJuO1xuICAgIHRoaXMuc3RhdGUuX3BvaW50ZXJBY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLnNldEFjdGl2ZSgpO1xuICAgIHRoaXMuY29tcHV0ZShldmVudCk7XG4gICAgY29uc3QgW2R4LCBkeV0gPSBzdGF0ZS5fZGlzdGFuY2U7XG4gICAgc3RhdGUudGFwID0gZHggPD0gY29uZmlnLnRhcHNUaHJlc2hvbGQgJiYgZHkgPD0gY29uZmlnLnRhcHNUaHJlc2hvbGQ7XG4gICAgaWYgKHN0YXRlLnRhcCAmJiBjb25maWcuZmlsdGVyVGFwcykge1xuICAgICAgc3RhdGUuX2ZvcmNlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW19keCwgX2R5XSA9IHN0YXRlLl9kZWx0YTtcbiAgICAgIGNvbnN0IFtfbXgsIF9teV0gPSBzdGF0ZS5fbW92ZW1lbnQ7XG4gICAgICBjb25zdCBbc3Z4LCBzdnldID0gY29uZmlnLnN3aXBlLnZlbG9jaXR5O1xuICAgICAgY29uc3QgW3N4LCBzeV0gPSBjb25maWcuc3dpcGUuZGlzdGFuY2U7XG4gICAgICBjb25zdCBzZHQgPSBjb25maWcuc3dpcGUuZHVyYXRpb247XG4gICAgICBpZiAoc3RhdGUuZWxhcHNlZFRpbWUgPCBzZHQpIHtcbiAgICAgICAgY29uc3QgX3Z4ID0gTWF0aC5hYnMoX2R4IC8gc3RhdGUudGltZURlbHRhKTtcbiAgICAgICAgY29uc3QgX3Z5ID0gTWF0aC5hYnMoX2R5IC8gc3RhdGUudGltZURlbHRhKTtcbiAgICAgICAgaWYgKF92eCA+IHN2eCAmJiBNYXRoLmFicyhfbXgpID4gc3gpIHN0YXRlLnN3aXBlWzBdID0gTWF0aC5zaWduKF9keCk7XG4gICAgICAgIGlmIChfdnkgPiBzdnkgJiYgTWF0aC5hYnMoX215KSA+IHN5KSBzdGF0ZS5zd2lwZVsxXSA9IE1hdGguc2lnbihfZHkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICBwb2ludGVyQ2xpY2soZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUudGFwICYmIGV2ZW50LmRldGFpbCA+IDApIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gIH1cbiAgc2V0dXBQb2ludGVyKGV2ZW50KSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgZGV2aWNlID0gY29uZmlnLmRldmljZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChkZXZpY2UgPT09ICdwb2ludGVyJyAmJiBjb25maWcucHJldmVudFNjcm9sbERlbGF5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50VGFyZ2V0ID0gJ3V2JyBpbiBldmVudCA/IGV2ZW50LnNvdXJjZUV2ZW50LmN1cnJlbnRUYXJnZXQgOiBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoY3VycmVudFRhcmdldCk7XG4gICAgICAgICAgaWYgKHN0eWxlLnRvdWNoQWN0aW9uID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW0B1c2UtZ2VzdHVyZV06IFRoZSBkcmFnIHRhcmdldCBoYXMgaXRzIFxcYHRvdWNoLWFjdGlvblxcYCBzdHlsZSBwcm9wZXJ0eSBzZXQgdG8gXFxgYXV0b1xcYC4gSXQgaXMgcmVjb21tZW5kZWQgdG8gYWRkIFxcYHRvdWNoLWFjdGlvbjogJ25vbmUnXFxgIHNvIHRoYXQgdGhlIGRyYWcgZ2VzdHVyZSBiZWhhdmVzIGNvcnJlY3RseSBvbiB0b3VjaC1lbmFibGVkIGRldmljZXMuIEZvciBtb3JlIGluZm9ybWF0aW9uIHJlYWQgdGhpczogaHR0cHM6Ly91c2UtZ2VzdHVyZS5uZXRsaWZ5LmFwcC9kb2NzL2V4dHJhcy8jdG91Y2gtYWN0aW9uLlxcblxcblRoaXMgbWVzc2FnZSB3aWxsIG9ubHkgc2hvdyBpbiBkZXZlbG9wbWVudCBtb2RlLiBJdCB3b24ndCBhcHBlYXIgaW4gcHJvZHVjdGlvbi4gSWYgdGhpcyBpcyBpbnRlbmRlZCwgeW91IGNhbiBpZ25vcmUgaXQuYCwgY3VycmVudFRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfdW51c2VkMikge31cbiAgICB9XG4gICAgaWYgKGNvbmZpZy5wb2ludGVyTG9jaykge1xuICAgICAgZXZlbnQuY3VycmVudFRhcmdldC5yZXF1ZXN0UG9pbnRlckxvY2soKTtcbiAgICB9XG4gICAgaWYgKCFjb25maWcucG9pbnRlckNhcHR1cmUpIHtcbiAgICAgIHRoaXMuZXZlbnRTdG9yZS5hZGQodGhpcy5zaGFyZWRDb25maWcud2luZG93LCBkZXZpY2UsICdjaGFuZ2UnLCB0aGlzLnBvaW50ZXJNb3ZlLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5ldmVudFN0b3JlLmFkZCh0aGlzLnNoYXJlZENvbmZpZy53aW5kb3csIGRldmljZSwgJ2VuZCcsIHRoaXMucG9pbnRlclVwLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5ldmVudFN0b3JlLmFkZCh0aGlzLnNoYXJlZENvbmZpZy53aW5kb3csIGRldmljZSwgJ2NhbmNlbCcsIHRoaXMucG9pbnRlclVwLmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxuICBwb2ludGVyQ2xlYW4oKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLnBvaW50ZXJMb2NrICYmIGRvY3VtZW50LnBvaW50ZXJMb2NrRWxlbWVudCA9PT0gdGhpcy5zdGF0ZS5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICBkb2N1bWVudC5leGl0UG9pbnRlckxvY2soKTtcbiAgICB9XG4gIH1cbiAgcHJldmVudFNjcm9sbChldmVudCkge1xuICAgIGlmICh0aGlzLnN0YXRlLl9wcmV2ZW50U2Nyb2xsICYmIGV2ZW50LmNhbmNlbGFibGUpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG4gIHNldHVwU2Nyb2xsUHJldmVudGlvbihldmVudCkge1xuICAgIHRoaXMuc3RhdGUuX3ByZXZlbnRTY3JvbGwgPSBmYWxzZTtcbiAgICBwZXJzaXN0RXZlbnQoZXZlbnQpO1xuICAgIGNvbnN0IHJlbW92ZSA9IHRoaXMuZXZlbnRTdG9yZS5hZGQodGhpcy5zaGFyZWRDb25maWcud2luZG93LCAndG91Y2gnLCAnY2hhbmdlJywgdGhpcy5wcmV2ZW50U2Nyb2xsLmJpbmQodGhpcyksIHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5ldmVudFN0b3JlLmFkZCh0aGlzLnNoYXJlZENvbmZpZy53aW5kb3csICd0b3VjaCcsICdlbmQnLCByZW1vdmUpO1xuICAgIHRoaXMuZXZlbnRTdG9yZS5hZGQodGhpcy5zaGFyZWRDb25maWcud2luZG93LCAndG91Y2gnLCAnY2FuY2VsJywgcmVtb3ZlKTtcbiAgICB0aGlzLnRpbWVvdXRTdG9yZS5hZGQoJ3N0YXJ0UG9pbnRlckRyYWcnLCB0aGlzLnN0YXJ0UG9pbnRlckRyYWcuYmluZCh0aGlzKSwgdGhpcy5jb25maWcucHJldmVudFNjcm9sbERlbGF5LCBldmVudCk7XG4gIH1cbiAgc2V0dXBEZWxheVRyaWdnZXIoZXZlbnQpIHtcbiAgICB0aGlzLnN0YXRlLl9kZWxheWVkID0gdHJ1ZTtcbiAgICB0aGlzLnRpbWVvdXRTdG9yZS5hZGQoJ2RyYWdEZWxheScsICgpID0+IHtcbiAgICAgIHRoaXMuc3RhdGUuX3N0ZXAgPSBbMCwgMF07XG4gICAgICB0aGlzLnN0YXJ0UG9pbnRlckRyYWcoZXZlbnQpO1xuICAgIH0sIHRoaXMuY29uZmlnLmRlbGF5KTtcbiAgfVxuICBrZXlEb3duKGV2ZW50KSB7XG4gICAgY29uc3QgZGVsdGFGbiA9IEtFWVNfREVMVEFfTUFQW2V2ZW50LmtleV07XG4gICAgaWYgKGRlbHRhRm4pIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IGZhY3RvciA9IGV2ZW50LnNoaWZ0S2V5ID8gMTAgOiBldmVudC5hbHRLZXkgPyAwLjEgOiAxO1xuICAgICAgdGhpcy5zdGFydChldmVudCk7XG4gICAgICBzdGF0ZS5fZGVsdGEgPSBkZWx0YUZuKHRoaXMuY29uZmlnLmtleWJvYXJkRGlzcGxhY2VtZW50LCBmYWN0b3IpO1xuICAgICAgc3RhdGUuX2tleWJvYXJkQWN0aXZlID0gdHJ1ZTtcbiAgICAgIFYuYWRkVG8oc3RhdGUuX21vdmVtZW50LCBzdGF0ZS5fZGVsdGEpO1xuICAgICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICAgIHRoaXMuZW1pdCgpO1xuICAgIH1cbiAgfVxuICBrZXlVcChldmVudCkge1xuICAgIGlmICghKGV2ZW50LmtleSBpbiBLRVlTX0RFTFRBX01BUCkpIHJldHVybjtcbiAgICB0aGlzLnN0YXRlLl9rZXlib2FyZEFjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuc2V0QWN0aXZlKCk7XG4gICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICBiaW5kKGJpbmRGdW5jdGlvbikge1xuICAgIGNvbnN0IGRldmljZSA9IHRoaXMuY29uZmlnLmRldmljZTtcbiAgICBiaW5kRnVuY3Rpb24oZGV2aWNlLCAnc3RhcnQnLCB0aGlzLnBvaW50ZXJEb3duLmJpbmQodGhpcykpO1xuICAgIGlmICh0aGlzLmNvbmZpZy5wb2ludGVyQ2FwdHVyZSkge1xuICAgICAgYmluZEZ1bmN0aW9uKGRldmljZSwgJ2NoYW5nZScsIHRoaXMucG9pbnRlck1vdmUuYmluZCh0aGlzKSk7XG4gICAgICBiaW5kRnVuY3Rpb24oZGV2aWNlLCAnZW5kJywgdGhpcy5wb2ludGVyVXAuYmluZCh0aGlzKSk7XG4gICAgICBiaW5kRnVuY3Rpb24oZGV2aWNlLCAnY2FuY2VsJywgdGhpcy5wb2ludGVyVXAuYmluZCh0aGlzKSk7XG4gICAgICBiaW5kRnVuY3Rpb24oJ2xvc3RQb2ludGVyQ2FwdHVyZScsICcnLCB0aGlzLnBvaW50ZXJVcC5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29uZmlnLmtleXMpIHtcbiAgICAgIGJpbmRGdW5jdGlvbigna2V5JywgJ2Rvd24nLCB0aGlzLmtleURvd24uYmluZCh0aGlzKSk7XG4gICAgICBiaW5kRnVuY3Rpb24oJ2tleScsICd1cCcsIHRoaXMua2V5VXAuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbmZpZy5maWx0ZXJUYXBzKSB7XG4gICAgICBiaW5kRnVuY3Rpb24oJ2NsaWNrJywgJycsIHRoaXMucG9pbnRlckNsaWNrLmJpbmQodGhpcyksIHtcbiAgICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcGVyc2lzdEV2ZW50KGV2ZW50KSB7XG4gICdwZXJzaXN0JyBpbiBldmVudCAmJiB0eXBlb2YgZXZlbnQucGVyc2lzdCA9PT0gJ2Z1bmN0aW9uJyAmJiBldmVudC5wZXJzaXN0KCk7XG59XG5cbmNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudDtcbmZ1bmN0aW9uIHN1cHBvcnRzVG91Y2hFdmVudHMoKSB7XG4gIHJldHVybiBpc0Jyb3dzZXIgJiYgJ29udG91Y2hzdGFydCcgaW4gd2luZG93O1xufVxuZnVuY3Rpb24gaXNUb3VjaFNjcmVlbigpIHtcbiAgcmV0dXJuIHN1cHBvcnRzVG91Y2hFdmVudHMoKSB8fCBpc0Jyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDE7XG59XG5mdW5jdGlvbiBzdXBwb3J0c1BvaW50ZXJFdmVudHMoKSB7XG4gIHJldHVybiBpc0Jyb3dzZXIgJiYgJ29ucG9pbnRlcmRvd24nIGluIHdpbmRvdztcbn1cbmZ1bmN0aW9uIHN1cHBvcnRzUG9pbnRlckxvY2soKSB7XG4gIHJldHVybiBpc0Jyb3dzZXIgJiYgJ2V4aXRQb2ludGVyTG9jaycgaW4gd2luZG93LmRvY3VtZW50O1xufVxuZnVuY3Rpb24gc3VwcG9ydHNHZXN0dXJlRXZlbnRzKCkge1xuICB0cnkge1xuICAgIHJldHVybiAnY29uc3RydWN0b3InIGluIEdlc3R1cmVFdmVudDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuY29uc3QgU1VQUE9SVCA9IHtcbiAgaXNCcm93c2VyLFxuICBnZXN0dXJlOiBzdXBwb3J0c0dlc3R1cmVFdmVudHMoKSxcbiAgdG91Y2g6IGlzVG91Y2hTY3JlZW4oKSxcbiAgdG91Y2hzY3JlZW46IGlzVG91Y2hTY3JlZW4oKSxcbiAgcG9pbnRlcjogc3VwcG9ydHNQb2ludGVyRXZlbnRzKCksXG4gIHBvaW50ZXJMb2NrOiBzdXBwb3J0c1BvaW50ZXJMb2NrKClcbn07XG5cbmNvbnN0IERFRkFVTFRfUFJFVkVOVF9TQ1JPTExfREVMQVkgPSAyNTA7XG5jb25zdCBERUZBVUxUX0RSQUdfREVMQVkgPSAxODA7XG5jb25zdCBERUZBVUxUX1NXSVBFX1ZFTE9DSVRZID0gMC41O1xuY29uc3QgREVGQVVMVF9TV0lQRV9ESVNUQU5DRSA9IDUwO1xuY29uc3QgREVGQVVMVF9TV0lQRV9EVVJBVElPTiA9IDI1MDtcbmNvbnN0IERFRkFVTFRfS0VZQk9BUkRfRElTUExBQ0VNRU5UID0gMTA7XG5jb25zdCBERUZBVUxUX0RSQUdfQVhJU19USFJFU0hPTEQgPSB7XG4gIG1vdXNlOiAwLFxuICB0b3VjaDogMCxcbiAgcGVuOiA4XG59O1xuY29uc3QgZHJhZ0NvbmZpZ1Jlc29sdmVyID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNvb3JkaW5hdGVzQ29uZmlnUmVzb2x2ZXIpLCB7fSwge1xuICBkZXZpY2UoX3YsIF9rLCB7XG4gICAgcG9pbnRlcjoge1xuICAgICAgdG91Y2ggPSBmYWxzZSxcbiAgICAgIGxvY2sgPSBmYWxzZSxcbiAgICAgIG1vdXNlID0gZmFsc2VcbiAgICB9ID0ge31cbiAgfSkge1xuICAgIHRoaXMucG9pbnRlckxvY2sgPSBsb2NrICYmIFNVUFBPUlQucG9pbnRlckxvY2s7XG4gICAgaWYgKFNVUFBPUlQudG91Y2ggJiYgdG91Y2gpIHJldHVybiAndG91Y2gnO1xuICAgIGlmICh0aGlzLnBvaW50ZXJMb2NrKSByZXR1cm4gJ21vdXNlJztcbiAgICBpZiAoU1VQUE9SVC5wb2ludGVyICYmICFtb3VzZSkgcmV0dXJuICdwb2ludGVyJztcbiAgICBpZiAoU1VQUE9SVC50b3VjaCkgcmV0dXJuICd0b3VjaCc7XG4gICAgcmV0dXJuICdtb3VzZSc7XG4gIH0sXG4gIHByZXZlbnRTY3JvbGxBeGlzKHZhbHVlLCBfaywge1xuICAgIHByZXZlbnRTY3JvbGxcbiAgfSkge1xuICAgIHRoaXMucHJldmVudFNjcm9sbERlbGF5ID0gdHlwZW9mIHByZXZlbnRTY3JvbGwgPT09ICdudW1iZXInID8gcHJldmVudFNjcm9sbCA6IHByZXZlbnRTY3JvbGwgfHwgcHJldmVudFNjcm9sbCA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID8gREVGQVVMVF9QUkVWRU5UX1NDUk9MTF9ERUxBWSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIVNVUFBPUlQudG91Y2hzY3JlZW4gfHwgcHJldmVudFNjcm9sbCA9PT0gZmFsc2UpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHZhbHVlID8gdmFsdWUgOiBwcmV2ZW50U2Nyb2xsICE9PSB1bmRlZmluZWQgPyAneScgOiB1bmRlZmluZWQ7XG4gIH0sXG4gIHBvaW50ZXJDYXB0dXJlKF92LCBfaywge1xuICAgIHBvaW50ZXI6IHtcbiAgICAgIGNhcHR1cmUgPSB0cnVlLFxuICAgICAgYnV0dG9ucyA9IDEsXG4gICAgICBrZXlzID0gdHJ1ZVxuICAgIH0gPSB7fVxuICB9KSB7XG4gICAgdGhpcy5wb2ludGVyQnV0dG9ucyA9IGJ1dHRvbnM7XG4gICAgdGhpcy5rZXlzID0ga2V5cztcbiAgICByZXR1cm4gIXRoaXMucG9pbnRlckxvY2sgJiYgdGhpcy5kZXZpY2UgPT09ICdwb2ludGVyJyAmJiBjYXB0dXJlO1xuICB9LFxuICB0aHJlc2hvbGQodmFsdWUsIF9rLCB7XG4gICAgZmlsdGVyVGFwcyA9IGZhbHNlLFxuICAgIHRhcHNUaHJlc2hvbGQgPSAzLFxuICAgIGF4aXMgPSB1bmRlZmluZWRcbiAgfSkge1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IFYudG9WZWN0b3IodmFsdWUsIGZpbHRlclRhcHMgPyB0YXBzVGhyZXNob2xkIDogYXhpcyA/IDEgOiAwKTtcbiAgICB0aGlzLmZpbHRlclRhcHMgPSBmaWx0ZXJUYXBzO1xuICAgIHRoaXMudGFwc1RocmVzaG9sZCA9IHRhcHNUaHJlc2hvbGQ7XG4gICAgcmV0dXJuIHRocmVzaG9sZDtcbiAgfSxcbiAgc3dpcGUoe1xuICAgIHZlbG9jaXR5ID0gREVGQVVMVF9TV0lQRV9WRUxPQ0lUWSxcbiAgICBkaXN0YW5jZSA9IERFRkFVTFRfU1dJUEVfRElTVEFOQ0UsXG4gICAgZHVyYXRpb24gPSBERUZBVUxUX1NXSVBFX0RVUkFUSU9OXG4gIH0gPSB7fSkge1xuICAgIHJldHVybiB7XG4gICAgICB2ZWxvY2l0eTogdGhpcy50cmFuc2Zvcm0oVi50b1ZlY3Rvcih2ZWxvY2l0eSkpLFxuICAgICAgZGlzdGFuY2U6IHRoaXMudHJhbnNmb3JtKFYudG9WZWN0b3IoZGlzdGFuY2UpKSxcbiAgICAgIGR1cmF0aW9uXG4gICAgfTtcbiAgfSxcbiAgZGVsYXkodmFsdWUgPSAwKSB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgY2FzZSB0cnVlOlxuICAgICAgICByZXR1cm4gREVGQVVMVF9EUkFHX0RFTEFZO1xuICAgICAgY2FzZSBmYWxzZTpcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9LFxuICBheGlzVGhyZXNob2xkKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuIERFRkFVTFRfRFJBR19BWElTX1RIUkVTSE9MRDtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfRFJBR19BWElTX1RIUkVTSE9MRCksIHZhbHVlKTtcbiAgfSxcbiAga2V5Ym9hcmREaXNwbGFjZW1lbnQodmFsdWUgPSBERUZBVUxUX0tFWUJPQVJEX0RJU1BMQUNFTUVOVCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufSk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgT2JqZWN0LmFzc2lnbihkcmFnQ29uZmlnUmVzb2x2ZXIsIHtcbiAgICB1c2VUb3VjaCh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFtAdXNlLWdlc3R1cmVdOiBcXGB1c2VUb3VjaFxcYCBvcHRpb24gaGFzIGJlZW4gcmVuYW1lZCB0byBcXGBwb2ludGVyLnRvdWNoXFxgLiBVc2UgaXQgYXMgaW4gXFxgeyBwb2ludGVyOiB7IHRvdWNoOiB0cnVlIH0gfVxcYC5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBOYU47XG4gICAgfSxcbiAgICBleHBlcmltZW50YWxfcHJldmVudFdpbmRvd1Njcm9sbFkodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBbQHVzZS1nZXN0dXJlXTogXFxgZXhwZXJpbWVudGFsX3ByZXZlbnRXaW5kb3dTY3JvbGxZXFxgIG9wdGlvbiBoYXMgYmVlbiByZW5hbWVkIHRvIFxcYHByZXZlbnRTY3JvbGxcXGAuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH0sXG4gICAgc3dpcGVWZWxvY2l0eSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFtAdXNlLWdlc3R1cmVdOiBcXGBzd2lwZVZlbG9jaXR5XFxgIG9wdGlvbiBoYXMgYmVlbiByZW5hbWVkIHRvIFxcYHN3aXBlLnZlbG9jaXR5XFxgLiBVc2UgaXQgYXMgaW4gXFxgeyBzd2lwZTogeyB2ZWxvY2l0eTogMC41IH0gfVxcYC5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBOYU47XG4gICAgfSxcbiAgICBzd2lwZURpc3RhbmNlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBFcnJvcihgW0B1c2UtZ2VzdHVyZV06IFxcYHN3aXBlRGlzdGFuY2VcXGAgb3B0aW9uIGhhcyBiZWVuIHJlbmFtZWQgdG8gXFxgc3dpcGUuZGlzdGFuY2VcXGAuIFVzZSBpdCBhcyBpbiBcXGB7IHN3aXBlOiB7IGRpc3RhbmNlOiA1MCB9IH1cXGAuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH0sXG4gICAgc3dpcGVEdXJhdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFtAdXNlLWdlc3R1cmVdOiBcXGBzd2lwZUR1cmF0aW9uXFxgIG9wdGlvbiBoYXMgYmVlbiByZW5hbWVkIHRvIFxcYHN3aXBlLmR1cmF0aW9uXFxgLiBVc2UgaXQgYXMgaW4gXFxgeyBzd2lwZTogeyBkdXJhdGlvbjogMjUwIH0gfVxcYC5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY2xhbXBTdGF0ZUludGVybmFsTW92ZW1lbnRUb0JvdW5kcyhzdGF0ZSkge1xuICBjb25zdCBbb3gsIG95XSA9IHN0YXRlLm92ZXJmbG93O1xuICBjb25zdCBbZHgsIGR5XSA9IHN0YXRlLl9kZWx0YTtcbiAgY29uc3QgW2RpcngsIGRpcnldID0gc3RhdGUuX2RpcmVjdGlvbjtcbiAgaWYgKG94IDwgMCAmJiBkeCA+IDAgJiYgZGlyeCA8IDAgfHwgb3ggPiAwICYmIGR4IDwgMCAmJiBkaXJ4ID4gMCkge1xuICAgIHN0YXRlLl9tb3ZlbWVudFswXSA9IHN0YXRlLl9tb3ZlbWVudEJvdW5kWzBdO1xuICB9XG4gIGlmIChveSA8IDAgJiYgZHkgPiAwICYmIGRpcnkgPCAwIHx8IG95ID4gMCAmJiBkeSA8IDAgJiYgZGlyeSA+IDApIHtcbiAgICBzdGF0ZS5fbW92ZW1lbnRbMV0gPSBzdGF0ZS5fbW92ZW1lbnRCb3VuZFsxXTtcbiAgfVxufVxuXG5jb25zdCBTQ0FMRV9BTkdMRV9SQVRJT19JTlRFTlRfREVHID0gMzA7XG5jb25zdCBQSU5DSF9XSEVFTF9SQVRJTyA9IDEwMDtcbmNsYXNzIFBpbmNoRW5naW5lIGV4dGVuZHMgRW5naW5lIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluZ0tleVwiLCAncGluY2hpbmcnKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJhbGlhc0tleVwiLCAnZGEnKTtcbiAgfVxuICBpbml0KCkge1xuICAgIHRoaXMuc3RhdGUub2Zmc2V0ID0gWzEsIDBdO1xuICAgIHRoaXMuc3RhdGUubGFzdE9mZnNldCA9IFsxLCAwXTtcbiAgICB0aGlzLnN0YXRlLl9wb2ludGVyRXZlbnRzID0gbmV3IE1hcCgpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHN1cGVyLnJlc2V0KCk7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHN0YXRlLl90b3VjaElkcyA9IFtdO1xuICAgIHN0YXRlLmNhbmNlbGVkID0gZmFsc2U7XG4gICAgc3RhdGUuY2FuY2VsID0gdGhpcy5jYW5jZWwuYmluZCh0aGlzKTtcbiAgICBzdGF0ZS50dXJucyA9IDA7XG4gIH1cbiAgY29tcHV0ZU9mZnNldCgpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlLFxuICAgICAgbW92ZW1lbnQsXG4gICAgICBsYXN0T2Zmc2V0XG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHR5cGUgPT09ICd3aGVlbCcpIHtcbiAgICAgIHRoaXMuc3RhdGUub2Zmc2V0ID0gVi5hZGQobW92ZW1lbnQsIGxhc3RPZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlLm9mZnNldCA9IFsoMSArIG1vdmVtZW50WzBdKSAqIGxhc3RPZmZzZXRbMF0sIG1vdmVtZW50WzFdICsgbGFzdE9mZnNldFsxXV07XG4gICAgfVxuICB9XG4gIGNvbXB1dGVNb3ZlbWVudCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBvZmZzZXQsXG4gICAgICBsYXN0T2Zmc2V0XG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgdGhpcy5zdGF0ZS5tb3ZlbWVudCA9IFtvZmZzZXRbMF0gLyBsYXN0T2Zmc2V0WzBdLCBvZmZzZXRbMV0gLSBsYXN0T2Zmc2V0WzFdXTtcbiAgfVxuICBheGlzSW50ZW50KCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBbX20wLCBfbTFdID0gc3RhdGUuX21vdmVtZW50O1xuICAgIGlmICghc3RhdGUuYXhpcykge1xuICAgICAgY29uc3QgYXhpc01vdmVtZW50RGlmZmVyZW5jZSA9IE1hdGguYWJzKF9tMCkgKiBTQ0FMRV9BTkdMRV9SQVRJT19JTlRFTlRfREVHIC0gTWF0aC5hYnMoX20xKTtcbiAgICAgIGlmIChheGlzTW92ZW1lbnREaWZmZXJlbmNlIDwgMCkgc3RhdGUuYXhpcyA9ICdhbmdsZSc7ZWxzZSBpZiAoYXhpc01vdmVtZW50RGlmZmVyZW5jZSA+IDApIHN0YXRlLmF4aXMgPSAnc2NhbGUnO1xuICAgIH1cbiAgfVxuICByZXN0cmljdFRvQXhpcyh2KSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLmxvY2tEaXJlY3Rpb24pIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmF4aXMgPT09ICdzY2FsZScpIHZbMV0gPSAwO2Vsc2UgaWYgKHRoaXMuc3RhdGUuYXhpcyA9PT0gJ2FuZ2xlJykgdlswXSA9IDA7XG4gICAgfVxuICB9XG4gIGNhbmNlbCgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHN0YXRlLmNhbmNlbGVkKSByZXR1cm47XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzdGF0ZS5jYW5jZWxlZCA9IHRydWU7XG4gICAgICBzdGF0ZS5fYWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLmNvbXB1dGUoKTtcbiAgICAgIHRoaXMuZW1pdCgpO1xuICAgIH0sIDApO1xuICB9XG4gIHRvdWNoU3RhcnQoZXZlbnQpIHtcbiAgICB0aGlzLmN0cmwuc2V0RXZlbnRJZHMoZXZlbnQpO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBjdHJsVG91Y2hJZHMgPSB0aGlzLmN0cmwudG91Y2hJZHM7XG4gICAgaWYgKHN0YXRlLl9hY3RpdmUpIHtcbiAgICAgIGlmIChzdGF0ZS5fdG91Y2hJZHMuZXZlcnkoaWQgPT4gY3RybFRvdWNoSWRzLmhhcyhpZCkpKSByZXR1cm47XG4gICAgfVxuICAgIGlmIChjdHJsVG91Y2hJZHMuc2l6ZSA8IDIpIHJldHVybjtcbiAgICB0aGlzLnN0YXJ0KGV2ZW50KTtcbiAgICBzdGF0ZS5fdG91Y2hJZHMgPSBBcnJheS5mcm9tKGN0cmxUb3VjaElkcykuc2xpY2UoMCwgMik7XG4gICAgY29uc3QgcGF5bG9hZCA9IHRvdWNoRGlzdGFuY2VBbmdsZShldmVudCwgc3RhdGUuX3RvdWNoSWRzKTtcbiAgICBpZiAoIXBheWxvYWQpIHJldHVybjtcbiAgICB0aGlzLnBpbmNoU3RhcnQoZXZlbnQsIHBheWxvYWQpO1xuICB9XG4gIHBvaW50ZXJTdGFydChldmVudCkge1xuICAgIGlmIChldmVudC5idXR0b25zICE9IG51bGwgJiYgZXZlbnQuYnV0dG9ucyAlIDIgIT09IDEpIHJldHVybjtcbiAgICB0aGlzLmN0cmwuc2V0RXZlbnRJZHMoZXZlbnQpO1xuICAgIGV2ZW50LnRhcmdldC5zZXRQb2ludGVyQ2FwdHVyZShldmVudC5wb2ludGVySWQpO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBfcG9pbnRlckV2ZW50cyA9IHN0YXRlLl9wb2ludGVyRXZlbnRzO1xuICAgIGNvbnN0IGN0cmxQb2ludGVySWRzID0gdGhpcy5jdHJsLnBvaW50ZXJJZHM7XG4gICAgaWYgKHN0YXRlLl9hY3RpdmUpIHtcbiAgICAgIGlmIChBcnJheS5mcm9tKF9wb2ludGVyRXZlbnRzLmtleXMoKSkuZXZlcnkoaWQgPT4gY3RybFBvaW50ZXJJZHMuaGFzKGlkKSkpIHJldHVybjtcbiAgICB9XG4gICAgaWYgKF9wb2ludGVyRXZlbnRzLnNpemUgPCAyKSB7XG4gICAgICBfcG9pbnRlckV2ZW50cy5zZXQoZXZlbnQucG9pbnRlcklkLCBldmVudCk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5fcG9pbnRlckV2ZW50cy5zaXplIDwgMikgcmV0dXJuO1xuICAgIHRoaXMuc3RhcnQoZXZlbnQpO1xuICAgIGNvbnN0IHBheWxvYWQgPSBkaXN0YW5jZUFuZ2xlKC4uLkFycmF5LmZyb20oX3BvaW50ZXJFdmVudHMudmFsdWVzKCkpKTtcbiAgICBpZiAoIXBheWxvYWQpIHJldHVybjtcbiAgICB0aGlzLnBpbmNoU3RhcnQoZXZlbnQsIHBheWxvYWQpO1xuICB9XG4gIHBpbmNoU3RhcnQoZXZlbnQsIHBheWxvYWQpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgc3RhdGUub3JpZ2luID0gcGF5bG9hZC5vcmlnaW47XG4gICAgdGhpcy5jb21wdXRlVmFsdWVzKFtwYXlsb2FkLmRpc3RhbmNlLCBwYXlsb2FkLmFuZ2xlXSk7XG4gICAgdGhpcy5jb21wdXRlSW5pdGlhbCgpO1xuICAgIHRoaXMuY29tcHV0ZShldmVudCk7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgdG91Y2hNb3ZlKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLl9hY3RpdmUpIHJldHVybjtcbiAgICBjb25zdCBwYXlsb2FkID0gdG91Y2hEaXN0YW5jZUFuZ2xlKGV2ZW50LCB0aGlzLnN0YXRlLl90b3VjaElkcyk7XG4gICAgaWYgKCFwYXlsb2FkKSByZXR1cm47XG4gICAgdGhpcy5waW5jaE1vdmUoZXZlbnQsIHBheWxvYWQpO1xuICB9XG4gIHBvaW50ZXJNb3ZlKGV2ZW50KSB7XG4gICAgY29uc3QgX3BvaW50ZXJFdmVudHMgPSB0aGlzLnN0YXRlLl9wb2ludGVyRXZlbnRzO1xuICAgIGlmIChfcG9pbnRlckV2ZW50cy5oYXMoZXZlbnQucG9pbnRlcklkKSkge1xuICAgICAgX3BvaW50ZXJFdmVudHMuc2V0KGV2ZW50LnBvaW50ZXJJZCwgZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc3RhdGUuX2FjdGl2ZSkgcmV0dXJuO1xuICAgIGNvbnN0IHBheWxvYWQgPSBkaXN0YW5jZUFuZ2xlKC4uLkFycmF5LmZyb20oX3BvaW50ZXJFdmVudHMudmFsdWVzKCkpKTtcbiAgICBpZiAoIXBheWxvYWQpIHJldHVybjtcbiAgICB0aGlzLnBpbmNoTW92ZShldmVudCwgcGF5bG9hZCk7XG4gIH1cbiAgcGluY2hNb3ZlKGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHByZXZfYSA9IHN0YXRlLl92YWx1ZXNbMV07XG4gICAgY29uc3QgZGVsdGFfYSA9IHBheWxvYWQuYW5nbGUgLSBwcmV2X2E7XG4gICAgbGV0IGRlbHRhX3R1cm5zID0gMDtcbiAgICBpZiAoTWF0aC5hYnMoZGVsdGFfYSkgPiAyNzApIGRlbHRhX3R1cm5zICs9IE1hdGguc2lnbihkZWx0YV9hKTtcbiAgICB0aGlzLmNvbXB1dGVWYWx1ZXMoW3BheWxvYWQuZGlzdGFuY2UsIHBheWxvYWQuYW5nbGUgLSAzNjAgKiBkZWx0YV90dXJuc10pO1xuICAgIHN0YXRlLm9yaWdpbiA9IHBheWxvYWQub3JpZ2luO1xuICAgIHN0YXRlLnR1cm5zID0gZGVsdGFfdHVybnM7XG4gICAgc3RhdGUuX21vdmVtZW50ID0gW3N0YXRlLl92YWx1ZXNbMF0gLyBzdGF0ZS5faW5pdGlhbFswXSAtIDEsIHN0YXRlLl92YWx1ZXNbMV0gLSBzdGF0ZS5faW5pdGlhbFsxXV07XG4gICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICB0b3VjaEVuZChldmVudCkge1xuICAgIHRoaXMuY3RybC5zZXRFdmVudElkcyhldmVudCk7XG4gICAgaWYgKCF0aGlzLnN0YXRlLl9hY3RpdmUpIHJldHVybjtcbiAgICBpZiAodGhpcy5zdGF0ZS5fdG91Y2hJZHMuc29tZShpZCA9PiAhdGhpcy5jdHJsLnRvdWNoSWRzLmhhcyhpZCkpKSB7XG4gICAgICB0aGlzLnN0YXRlLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuY29tcHV0ZShldmVudCk7XG4gICAgICB0aGlzLmVtaXQoKTtcbiAgICB9XG4gIH1cbiAgcG9pbnRlckVuZChldmVudCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB0aGlzLmN0cmwuc2V0RXZlbnRJZHMoZXZlbnQpO1xuICAgIHRyeSB7XG4gICAgICBldmVudC50YXJnZXQucmVsZWFzZVBvaW50ZXJDYXB0dXJlKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgfSBjYXRjaCAoX3VudXNlZCkge31cbiAgICBpZiAoc3RhdGUuX3BvaW50ZXJFdmVudHMuaGFzKGV2ZW50LnBvaW50ZXJJZCkpIHtcbiAgICAgIHN0YXRlLl9wb2ludGVyRXZlbnRzLmRlbGV0ZShldmVudC5wb2ludGVySWQpO1xuICAgIH1cbiAgICBpZiAoIXN0YXRlLl9hY3RpdmUpIHJldHVybjtcbiAgICBpZiAoc3RhdGUuX3BvaW50ZXJFdmVudHMuc2l6ZSA8IDIpIHtcbiAgICAgIHN0YXRlLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuY29tcHV0ZShldmVudCk7XG4gICAgICB0aGlzLmVtaXQoKTtcbiAgICB9XG4gIH1cbiAgZ2VzdHVyZVN0YXJ0KGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmNhbmNlbGFibGUpIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmIChzdGF0ZS5fYWN0aXZlKSByZXR1cm47XG4gICAgdGhpcy5zdGFydChldmVudCk7XG4gICAgdGhpcy5jb21wdXRlVmFsdWVzKFtldmVudC5zY2FsZSwgZXZlbnQucm90YXRpb25dKTtcbiAgICBzdGF0ZS5vcmlnaW4gPSBbZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WV07XG4gICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICBnZXN0dXJlTW92ZShldmVudCkge1xuICAgIGlmIChldmVudC5jYW5jZWxhYmxlKSBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICghdGhpcy5zdGF0ZS5fYWN0aXZlKSByZXR1cm47XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHRoaXMuY29tcHV0ZVZhbHVlcyhbZXZlbnQuc2NhbGUsIGV2ZW50LnJvdGF0aW9uXSk7XG4gICAgc3RhdGUub3JpZ2luID0gW2V2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFldO1xuICAgIGNvbnN0IF9wcmV2aW91c01vdmVtZW50ID0gc3RhdGUuX21vdmVtZW50O1xuICAgIHN0YXRlLl9tb3ZlbWVudCA9IFtldmVudC5zY2FsZSAtIDEsIGV2ZW50LnJvdGF0aW9uXTtcbiAgICBzdGF0ZS5fZGVsdGEgPSBWLnN1YihzdGF0ZS5fbW92ZW1lbnQsIF9wcmV2aW91c01vdmVtZW50KTtcbiAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIGdlc3R1cmVFbmQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuX2FjdGl2ZSkgcmV0dXJuO1xuICAgIHRoaXMuc3RhdGUuX2FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuY29tcHV0ZShldmVudCk7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgd2hlZWwoZXZlbnQpIHtcbiAgICBjb25zdCBtb2RpZmllcktleSA9IHRoaXMuY29uZmlnLm1vZGlmaWVyS2V5O1xuICAgIGlmIChtb2RpZmllcktleSAmJiAhZXZlbnRbbW9kaWZpZXJLZXldKSByZXR1cm47XG4gICAgaWYgKCF0aGlzLnN0YXRlLl9hY3RpdmUpIHRoaXMud2hlZWxTdGFydChldmVudCk7ZWxzZSB0aGlzLndoZWVsQ2hhbmdlKGV2ZW50KTtcbiAgICB0aGlzLnRpbWVvdXRTdG9yZS5hZGQoJ3doZWVsRW5kJywgdGhpcy53aGVlbEVuZC5iaW5kKHRoaXMpKTtcbiAgfVxuICB3aGVlbFN0YXJ0KGV2ZW50KSB7XG4gICAgdGhpcy5zdGFydChldmVudCk7XG4gICAgdGhpcy53aGVlbENoYW5nZShldmVudCk7XG4gIH1cbiAgd2hlZWxDaGFuZ2UoZXZlbnQpIHtcbiAgICBjb25zdCBpc1IzZiA9ICgndXYnIGluIGV2ZW50KTtcbiAgICBpZiAoIWlzUjNmKSB7XG4gICAgICBpZiAoZXZlbnQuY2FuY2VsYWJsZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgW0B1c2UtZ2VzdHVyZV06IFRvIHByb3Blcmx5IHN1cHBvcnQgem9vbSBvbiB0cmFja3BhZHMsIHRyeSB1c2luZyB0aGUgXFxgdGFyZ2V0XFxgIG9wdGlvbi5cXG5cXG5UaGlzIG1lc3NhZ2Ugd2lsbCBvbmx5IGFwcGVhciBpbiBkZXZlbG9wbWVudCBtb2RlLmApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgc3RhdGUuX2RlbHRhID0gWy13aGVlbFZhbHVlcyhldmVudClbMV0gLyBQSU5DSF9XSEVFTF9SQVRJTyAqIHN0YXRlLm9mZnNldFswXSwgMF07XG4gICAgVi5hZGRUbyhzdGF0ZS5fbW92ZW1lbnQsIHN0YXRlLl9kZWx0YSk7XG4gICAgY2xhbXBTdGF0ZUludGVybmFsTW92ZW1lbnRUb0JvdW5kcyhzdGF0ZSk7XG4gICAgdGhpcy5zdGF0ZS5vcmlnaW4gPSBbZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WV07XG4gICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICB3aGVlbEVuZCgpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuX2FjdGl2ZSkgcmV0dXJuO1xuICAgIHRoaXMuc3RhdGUuX2FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuY29tcHV0ZSgpO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIGJpbmQoYmluZEZ1bmN0aW9uKSB7XG4gICAgY29uc3QgZGV2aWNlID0gdGhpcy5jb25maWcuZGV2aWNlO1xuICAgIGlmICghIWRldmljZSkge1xuICAgICAgYmluZEZ1bmN0aW9uKGRldmljZSwgJ3N0YXJ0JywgdGhpc1tkZXZpY2UgKyAnU3RhcnQnXS5iaW5kKHRoaXMpKTtcbiAgICAgIGJpbmRGdW5jdGlvbihkZXZpY2UsICdjaGFuZ2UnLCB0aGlzW2RldmljZSArICdNb3ZlJ10uYmluZCh0aGlzKSk7XG4gICAgICBiaW5kRnVuY3Rpb24oZGV2aWNlLCAnZW5kJywgdGhpc1tkZXZpY2UgKyAnRW5kJ10uYmluZCh0aGlzKSk7XG4gICAgICBiaW5kRnVuY3Rpb24oZGV2aWNlLCAnY2FuY2VsJywgdGhpc1tkZXZpY2UgKyAnRW5kJ10uYmluZCh0aGlzKSk7XG4gICAgICBiaW5kRnVuY3Rpb24oJ2xvc3RQb2ludGVyQ2FwdHVyZScsICcnLCB0aGlzW2RldmljZSArICdFbmQnXS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29uZmlnLnBpbmNoT25XaGVlbCkge1xuICAgICAgYmluZEZ1bmN0aW9uKCd3aGVlbCcsICcnLCB0aGlzLndoZWVsLmJpbmQodGhpcyksIHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBwaW5jaENvbmZpZ1Jlc29sdmVyID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNvbW1vbkNvbmZpZ1Jlc29sdmVyKSwge30sIHtcbiAgZGV2aWNlKF92LCBfaywge1xuICAgIHNoYXJlZCxcbiAgICBwb2ludGVyOiB7XG4gICAgICB0b3VjaCA9IGZhbHNlXG4gICAgfSA9IHt9XG4gIH0pIHtcbiAgICBjb25zdCBzaGFyZWRDb25maWcgPSBzaGFyZWQ7XG4gICAgaWYgKHNoYXJlZENvbmZpZy50YXJnZXQgJiYgIVNVUFBPUlQudG91Y2ggJiYgU1VQUE9SVC5nZXN0dXJlKSByZXR1cm4gJ2dlc3R1cmUnO1xuICAgIGlmIChTVVBQT1JULnRvdWNoICYmIHRvdWNoKSByZXR1cm4gJ3RvdWNoJztcbiAgICBpZiAoU1VQUE9SVC50b3VjaHNjcmVlbikge1xuICAgICAgaWYgKFNVUFBPUlQucG9pbnRlcikgcmV0dXJuICdwb2ludGVyJztcbiAgICAgIGlmIChTVVBQT1JULnRvdWNoKSByZXR1cm4gJ3RvdWNoJztcbiAgICB9XG4gIH0sXG4gIGJvdW5kcyhfdiwgX2ssIHtcbiAgICBzY2FsZUJvdW5kcyA9IHt9LFxuICAgIGFuZ2xlQm91bmRzID0ge31cbiAgfSkge1xuICAgIGNvbnN0IF9zY2FsZUJvdW5kcyA9IHN0YXRlID0+IHtcbiAgICAgIGNvbnN0IEQgPSBhc3NpZ25EZWZhdWx0KGNhbGwoc2NhbGVCb3VuZHMsIHN0YXRlKSwge1xuICAgICAgICBtaW46IC1JbmZpbml0eSxcbiAgICAgICAgbWF4OiBJbmZpbml0eVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gW0QubWluLCBELm1heF07XG4gICAgfTtcbiAgICBjb25zdCBfYW5nbGVCb3VuZHMgPSBzdGF0ZSA9PiB7XG4gICAgICBjb25zdCBBID0gYXNzaWduRGVmYXVsdChjYWxsKGFuZ2xlQm91bmRzLCBzdGF0ZSksIHtcbiAgICAgICAgbWluOiAtSW5maW5pdHksXG4gICAgICAgIG1heDogSW5maW5pdHlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFtBLm1pbiwgQS5tYXhdO1xuICAgIH07XG4gICAgaWYgKHR5cGVvZiBzY2FsZUJvdW5kcyAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgYW5nbGVCb3VuZHMgIT09ICdmdW5jdGlvbicpIHJldHVybiBbX3NjYWxlQm91bmRzKCksIF9hbmdsZUJvdW5kcygpXTtcbiAgICByZXR1cm4gc3RhdGUgPT4gW19zY2FsZUJvdW5kcyhzdGF0ZSksIF9hbmdsZUJvdW5kcyhzdGF0ZSldO1xuICB9LFxuICB0aHJlc2hvbGQodmFsdWUsIF9rLCBjb25maWcpIHtcbiAgICB0aGlzLmxvY2tEaXJlY3Rpb24gPSBjb25maWcuYXhpcyA9PT0gJ2xvY2snO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IFYudG9WZWN0b3IodmFsdWUsIHRoaXMubG9ja0RpcmVjdGlvbiA/IFswLjEsIDNdIDogMCk7XG4gICAgcmV0dXJuIHRocmVzaG9sZDtcbiAgfSxcbiAgbW9kaWZpZXJLZXkodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuICdjdHJsS2V5JztcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIHBpbmNoT25XaGVlbCh2YWx1ZSA9IHRydWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn0pO1xuXG5jbGFzcyBNb3ZlRW5naW5lIGV4dGVuZHMgQ29vcmRpbmF0ZXNFbmdpbmUge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5nS2V5XCIsICdtb3ZpbmcnKTtcbiAgfVxuICBtb3ZlKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLm1vdXNlT25seSAmJiBldmVudC5wb2ludGVyVHlwZSAhPT0gJ21vdXNlJykgcmV0dXJuO1xuICAgIGlmICghdGhpcy5zdGF0ZS5fYWN0aXZlKSB0aGlzLm1vdmVTdGFydChldmVudCk7ZWxzZSB0aGlzLm1vdmVDaGFuZ2UoZXZlbnQpO1xuICAgIHRoaXMudGltZW91dFN0b3JlLmFkZCgnbW92ZUVuZCcsIHRoaXMubW92ZUVuZC5iaW5kKHRoaXMpKTtcbiAgfVxuICBtb3ZlU3RhcnQoZXZlbnQpIHtcbiAgICB0aGlzLnN0YXJ0KGV2ZW50KTtcbiAgICB0aGlzLmNvbXB1dGVWYWx1ZXMocG9pbnRlclZhbHVlcyhldmVudCkpO1xuICAgIHRoaXMuY29tcHV0ZShldmVudCk7XG4gICAgdGhpcy5jb21wdXRlSW5pdGlhbCgpO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIG1vdmVDaGFuZ2UoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuX2FjdGl2ZSkgcmV0dXJuO1xuICAgIGNvbnN0IHZhbHVlcyA9IHBvaW50ZXJWYWx1ZXMoZXZlbnQpO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBzdGF0ZS5fZGVsdGEgPSBWLnN1Yih2YWx1ZXMsIHN0YXRlLl92YWx1ZXMpO1xuICAgIFYuYWRkVG8oc3RhdGUuX21vdmVtZW50LCBzdGF0ZS5fZGVsdGEpO1xuICAgIHRoaXMuY29tcHV0ZVZhbHVlcyh2YWx1ZXMpO1xuICAgIHRoaXMuY29tcHV0ZShldmVudCk7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgbW92ZUVuZChldmVudCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5fYWN0aXZlKSByZXR1cm47XG4gICAgdGhpcy5zdGF0ZS5fYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICBiaW5kKGJpbmRGdW5jdGlvbikge1xuICAgIGJpbmRGdW5jdGlvbigncG9pbnRlcicsICdjaGFuZ2UnLCB0aGlzLm1vdmUuYmluZCh0aGlzKSk7XG4gICAgYmluZEZ1bmN0aW9uKCdwb2ludGVyJywgJ2xlYXZlJywgdGhpcy5tb3ZlRW5kLmJpbmQodGhpcykpO1xuICB9XG59XG5cbmNvbnN0IG1vdmVDb25maWdSZXNvbHZlciA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjb29yZGluYXRlc0NvbmZpZ1Jlc29sdmVyKSwge30sIHtcbiAgbW91c2VPbmx5OiAodmFsdWUgPSB0cnVlKSA9PiB2YWx1ZVxufSk7XG5cbmNsYXNzIFNjcm9sbEVuZ2luZSBleHRlbmRzIENvb3JkaW5hdGVzRW5naW5lIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluZ0tleVwiLCAnc2Nyb2xsaW5nJyk7XG4gIH1cbiAgc2Nyb2xsKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLl9hY3RpdmUpIHRoaXMuc3RhcnQoZXZlbnQpO1xuICAgIHRoaXMuc2Nyb2xsQ2hhbmdlKGV2ZW50KTtcbiAgICB0aGlzLnRpbWVvdXRTdG9yZS5hZGQoJ3Njcm9sbEVuZCcsIHRoaXMuc2Nyb2xsRW5kLmJpbmQodGhpcykpO1xuICB9XG4gIHNjcm9sbENoYW5nZShldmVudCkge1xuICAgIGlmIChldmVudC5jYW5jZWxhYmxlKSBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB2YWx1ZXMgPSBzY3JvbGxWYWx1ZXMoZXZlbnQpO1xuICAgIHN0YXRlLl9kZWx0YSA9IFYuc3ViKHZhbHVlcywgc3RhdGUuX3ZhbHVlcyk7XG4gICAgVi5hZGRUbyhzdGF0ZS5fbW92ZW1lbnQsIHN0YXRlLl9kZWx0YSk7XG4gICAgdGhpcy5jb21wdXRlVmFsdWVzKHZhbHVlcyk7XG4gICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICBzY3JvbGxFbmQoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLl9hY3RpdmUpIHJldHVybjtcbiAgICB0aGlzLnN0YXRlLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmNvbXB1dGUoKTtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICBiaW5kKGJpbmRGdW5jdGlvbikge1xuICAgIGJpbmRGdW5jdGlvbignc2Nyb2xsJywgJycsIHRoaXMuc2Nyb2xsLmJpbmQodGhpcykpO1xuICB9XG59XG5cbmNvbnN0IHNjcm9sbENvbmZpZ1Jlc29sdmVyID0gY29vcmRpbmF0ZXNDb25maWdSZXNvbHZlcjtcblxuY2xhc3MgV2hlZWxFbmdpbmUgZXh0ZW5kcyBDb29yZGluYXRlc0VuZ2luZSB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmdLZXlcIiwgJ3doZWVsaW5nJyk7XG4gIH1cbiAgd2hlZWwoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuX2FjdGl2ZSkgdGhpcy5zdGFydChldmVudCk7XG4gICAgdGhpcy53aGVlbENoYW5nZShldmVudCk7XG4gICAgdGhpcy50aW1lb3V0U3RvcmUuYWRkKCd3aGVlbEVuZCcsIHRoaXMud2hlZWxFbmQuYmluZCh0aGlzKSk7XG4gIH1cbiAgd2hlZWxDaGFuZ2UoZXZlbnQpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgc3RhdGUuX2RlbHRhID0gd2hlZWxWYWx1ZXMoZXZlbnQpO1xuICAgIFYuYWRkVG8oc3RhdGUuX21vdmVtZW50LCBzdGF0ZS5fZGVsdGEpO1xuICAgIGNsYW1wU3RhdGVJbnRlcm5hbE1vdmVtZW50VG9Cb3VuZHMoc3RhdGUpO1xuICAgIHRoaXMuY29tcHV0ZShldmVudCk7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgd2hlZWxFbmQoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLl9hY3RpdmUpIHJldHVybjtcbiAgICB0aGlzLnN0YXRlLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmNvbXB1dGUoKTtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICBiaW5kKGJpbmRGdW5jdGlvbikge1xuICAgIGJpbmRGdW5jdGlvbignd2hlZWwnLCAnJywgdGhpcy53aGVlbC5iaW5kKHRoaXMpKTtcbiAgfVxufVxuXG5jb25zdCB3aGVlbENvbmZpZ1Jlc29sdmVyID0gY29vcmRpbmF0ZXNDb25maWdSZXNvbHZlcjtcblxuY2xhc3MgSG92ZXJFbmdpbmUgZXh0ZW5kcyBDb29yZGluYXRlc0VuZ2luZSB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmdLZXlcIiwgJ2hvdmVyaW5nJyk7XG4gIH1cbiAgZW50ZXIoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5jb25maWcubW91c2VPbmx5ICYmIGV2ZW50LnBvaW50ZXJUeXBlICE9PSAnbW91c2UnKSByZXR1cm47XG4gICAgdGhpcy5zdGFydChldmVudCk7XG4gICAgdGhpcy5jb21wdXRlVmFsdWVzKHBvaW50ZXJWYWx1ZXMoZXZlbnQpKTtcbiAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIGxlYXZlKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLm1vdXNlT25seSAmJiBldmVudC5wb2ludGVyVHlwZSAhPT0gJ21vdXNlJykgcmV0dXJuO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoIXN0YXRlLl9hY3RpdmUpIHJldHVybjtcbiAgICBzdGF0ZS5fYWN0aXZlID0gZmFsc2U7XG4gICAgY29uc3QgdmFsdWVzID0gcG9pbnRlclZhbHVlcyhldmVudCk7XG4gICAgc3RhdGUuX21vdmVtZW50ID0gc3RhdGUuX2RlbHRhID0gVi5zdWIodmFsdWVzLCBzdGF0ZS5fdmFsdWVzKTtcbiAgICB0aGlzLmNvbXB1dGVWYWx1ZXModmFsdWVzKTtcbiAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgIHN0YXRlLmRlbHRhID0gc3RhdGUubW92ZW1lbnQ7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgYmluZChiaW5kRnVuY3Rpb24pIHtcbiAgICBiaW5kRnVuY3Rpb24oJ3BvaW50ZXInLCAnZW50ZXInLCB0aGlzLmVudGVyLmJpbmQodGhpcykpO1xuICAgIGJpbmRGdW5jdGlvbigncG9pbnRlcicsICdsZWF2ZScsIHRoaXMubGVhdmUuYmluZCh0aGlzKSk7XG4gIH1cbn1cblxuY29uc3QgaG92ZXJDb25maWdSZXNvbHZlciA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjb29yZGluYXRlc0NvbmZpZ1Jlc29sdmVyKSwge30sIHtcbiAgbW91c2VPbmx5OiAodmFsdWUgPSB0cnVlKSA9PiB2YWx1ZVxufSk7XG5cbmNvbnN0IEVuZ2luZU1hcCA9IG5ldyBNYXAoKTtcbmNvbnN0IENvbmZpZ1Jlc29sdmVyTWFwID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gcmVnaXN0ZXJBY3Rpb24oYWN0aW9uKSB7XG4gIEVuZ2luZU1hcC5zZXQoYWN0aW9uLmtleSwgYWN0aW9uLmVuZ2luZSk7XG4gIENvbmZpZ1Jlc29sdmVyTWFwLnNldChhY3Rpb24ua2V5LCBhY3Rpb24ucmVzb2x2ZXIpO1xufVxuY29uc3QgZHJhZ0FjdGlvbiA9IHtcbiAga2V5OiAnZHJhZycsXG4gIGVuZ2luZTogRHJhZ0VuZ2luZSxcbiAgcmVzb2x2ZXI6IGRyYWdDb25maWdSZXNvbHZlclxufTtcbmNvbnN0IGhvdmVyQWN0aW9uID0ge1xuICBrZXk6ICdob3ZlcicsXG4gIGVuZ2luZTogSG92ZXJFbmdpbmUsXG4gIHJlc29sdmVyOiBob3ZlckNvbmZpZ1Jlc29sdmVyXG59O1xuY29uc3QgbW92ZUFjdGlvbiA9IHtcbiAga2V5OiAnbW92ZScsXG4gIGVuZ2luZTogTW92ZUVuZ2luZSxcbiAgcmVzb2x2ZXI6IG1vdmVDb25maWdSZXNvbHZlclxufTtcbmNvbnN0IHBpbmNoQWN0aW9uID0ge1xuICBrZXk6ICdwaW5jaCcsXG4gIGVuZ2luZTogUGluY2hFbmdpbmUsXG4gIHJlc29sdmVyOiBwaW5jaENvbmZpZ1Jlc29sdmVyXG59O1xuY29uc3Qgc2Nyb2xsQWN0aW9uID0ge1xuICBrZXk6ICdzY3JvbGwnLFxuICBlbmdpbmU6IFNjcm9sbEVuZ2luZSxcbiAgcmVzb2x2ZXI6IHNjcm9sbENvbmZpZ1Jlc29sdmVyXG59O1xuY29uc3Qgd2hlZWxBY3Rpb24gPSB7XG4gIGtleTogJ3doZWVsJyxcbiAgZW5naW5lOiBXaGVlbEVuZ2luZSxcbiAgcmVzb2x2ZXI6IHdoZWVsQ29uZmlnUmVzb2x2ZXJcbn07XG5cbmV4cG9ydCB7IENvbmZpZ1Jlc29sdmVyTWFwIGFzIEMsIEVuZ2luZU1hcCBhcyBFLCBTVVBQT1JUIGFzIFMsIF9vYmplY3RTcHJlYWQyIGFzIF8sIF9kZWZpbmVQcm9wZXJ0eSBhcyBhLCB0b3VjaElkcyBhcyBiLCBjaGFpbiBhcyBjLCB0b0hhbmRsZXJQcm9wIGFzIGQsIGRyYWdBY3Rpb24gYXMgZSwgcGluY2hBY3Rpb24gYXMgZiwgaG92ZXJBY3Rpb24gYXMgaCwgaXNUb3VjaCBhcyBpLCBtb3ZlQWN0aW9uIGFzIG0sIHBhcnNlUHJvcCBhcyBwLCByZWdpc3RlckFjdGlvbiBhcyByLCBzY3JvbGxBY3Rpb24gYXMgcywgdG9Eb21FdmVudFR5cGUgYXMgdCwgd2hlZWxBY3Rpb24gYXMgdyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@use-gesture/core/dist/actions-76b8683e.esm.js\n");

/***/ }),

/***/ "./node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"V\": function() { return /* binding */ V; },\n/* harmony export */   \"c\": function() { return /* binding */ computeRubberband; },\n/* harmony export */   \"r\": function() { return /* binding */ rubberbandIfOutOfBounds; }\n/* harmony export */ });\nfunction clamp(v, min, max) {\n  return Math.max(min, Math.min(v, max));\n}\nconst V = {\n  toVector(v, fallback) {\n    if (v === undefined) v = fallback;\n    return Array.isArray(v) ? v : [v, v];\n  },\n  add(v1, v2) {\n    return [v1[0] + v2[0], v1[1] + v2[1]];\n  },\n  sub(v1, v2) {\n    return [v1[0] - v2[0], v1[1] - v2[1]];\n  },\n  addTo(v1, v2) {\n    v1[0] += v2[0];\n    v1[1] += v2[1];\n  },\n  subTo(v1, v2) {\n    v1[0] -= v2[0];\n    v1[1] -= v2[1];\n  }\n};\nfunction rubberband(distance, dimension, constant) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return Math.pow(distance, constant * 5);\n  return distance * dimension * constant / (dimension + constant * distance);\n}\nfunction rubberbandIfOutOfBounds(position, min, max, constant = 0.15) {\n  if (constant === 0) return clamp(position, min, max);\n  if (position < min) return -rubberband(min - position, max - min, constant) + min;\n  if (position > max) return +rubberband(position - max, max - min, constant) + max;\n  return position;\n}\nfunction computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {\n  const [[X0, X1], [Y0, Y1]] = bounds;\n  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVzZS1nZXN0dXJlL2NvcmUvZGlzdC9tYXRocy0wYWIzOWFlOS5lc20uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvZHVjdGlvbnByb2plY3QvLi9ub2RlX21vZHVsZXMvQHVzZS1nZXN0dXJlL2NvcmUvZGlzdC9tYXRocy0wYWIzOWFlOS5lc20uanM/MGZlZCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBjbGFtcCh2LCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbih2LCBtYXgpKTtcbn1cbmNvbnN0IFYgPSB7XG4gIHRvVmVjdG9yKHYsIGZhbGxiYWNrKSB7XG4gICAgaWYgKHYgPT09IHVuZGVmaW5lZCkgdiA9IGZhbGxiYWNrO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHYpID8gdiA6IFt2LCB2XTtcbiAgfSxcbiAgYWRkKHYxLCB2Mikge1xuICAgIHJldHVybiBbdjFbMF0gKyB2MlswXSwgdjFbMV0gKyB2MlsxXV07XG4gIH0sXG4gIHN1Yih2MSwgdjIpIHtcbiAgICByZXR1cm4gW3YxWzBdIC0gdjJbMF0sIHYxWzFdIC0gdjJbMV1dO1xuICB9LFxuICBhZGRUbyh2MSwgdjIpIHtcbiAgICB2MVswXSArPSB2MlswXTtcbiAgICB2MVsxXSArPSB2MlsxXTtcbiAgfSxcbiAgc3ViVG8odjEsIHYyKSB7XG4gICAgdjFbMF0gLT0gdjJbMF07XG4gICAgdjFbMV0gLT0gdjJbMV07XG4gIH1cbn07XG5mdW5jdGlvbiBydWJiZXJiYW5kKGRpc3RhbmNlLCBkaW1lbnNpb24sIGNvbnN0YW50KSB7XG4gIGlmIChkaW1lbnNpb24gPT09IDAgfHwgTWF0aC5hYnMoZGltZW5zaW9uKSA9PT0gSW5maW5pdHkpIHJldHVybiBNYXRoLnBvdyhkaXN0YW5jZSwgY29uc3RhbnQgKiA1KTtcbiAgcmV0dXJuIGRpc3RhbmNlICogZGltZW5zaW9uICogY29uc3RhbnQgLyAoZGltZW5zaW9uICsgY29uc3RhbnQgKiBkaXN0YW5jZSk7XG59XG5mdW5jdGlvbiBydWJiZXJiYW5kSWZPdXRPZkJvdW5kcyhwb3NpdGlvbiwgbWluLCBtYXgsIGNvbnN0YW50ID0gMC4xNSkge1xuICBpZiAoY29uc3RhbnQgPT09IDApIHJldHVybiBjbGFtcChwb3NpdGlvbiwgbWluLCBtYXgpO1xuICBpZiAocG9zaXRpb24gPCBtaW4pIHJldHVybiAtcnViYmVyYmFuZChtaW4gLSBwb3NpdGlvbiwgbWF4IC0gbWluLCBjb25zdGFudCkgKyBtaW47XG4gIGlmIChwb3NpdGlvbiA+IG1heCkgcmV0dXJuICtydWJiZXJiYW5kKHBvc2l0aW9uIC0gbWF4LCBtYXggLSBtaW4sIGNvbnN0YW50KSArIG1heDtcbiAgcmV0dXJuIHBvc2l0aW9uO1xufVxuZnVuY3Rpb24gY29tcHV0ZVJ1YmJlcmJhbmQoYm91bmRzLCBbVngsIFZ5XSwgW1J4LCBSeV0pIHtcbiAgY29uc3QgW1tYMCwgWDFdLCBbWTAsIFkxXV0gPSBib3VuZHM7XG4gIHJldHVybiBbcnViYmVyYmFuZElmT3V0T2ZCb3VuZHMoVngsIFgwLCBYMSwgUngpLCBydWJiZXJiYW5kSWZPdXRPZkJvdW5kcyhWeSwgWTAsIFkxLCBSeSldO1xufVxuXG5leHBvcnQgeyBWLCBjb21wdXRlUnViYmVyYmFuZCBhcyBjLCBydWJiZXJiYW5kSWZPdXRPZkJvdW5kcyBhcyByIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js\n");

/***/ }),

/***/ "./node_modules/@use-gesture/core/dist/use-gesture-core.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@use-gesture/core/dist/use-gesture-core.esm.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Controller\": function() { return /* binding */ Controller; },\n/* harmony export */   \"parseMergedHandlers\": function() { return /* binding */ parseMergedHandlers; }\n/* harmony export */ });\n/* harmony import */ var _actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actions-76b8683e.esm.js */ \"./node_modules/@use-gesture/core/dist/actions-76b8683e.esm.js\");\n\n\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\nconst sharedConfigResolver = {\n  target(value) {\n    if (value) {\n      return () => 'current' in value ? value.current : value;\n    }\n    return undefined;\n  },\n  enabled(value = true) {\n    return value;\n  },\n  window(value = _actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.S.isBrowser ? window : undefined) {\n    return value;\n  },\n  eventOptions({\n    passive = true,\n    capture = false\n  } = {}) {\n    return {\n      passive,\n      capture\n    };\n  },\n  transform(value) {\n    return value;\n  }\n};\n\nconst _excluded = [\"target\", \"eventOptions\", \"window\", \"enabled\", \"transform\"];\nfunction resolveWith(config = {}, resolvers) {\n  const result = {};\n  for (const [key, resolver] of Object.entries(resolvers)) {\n    switch (typeof resolver) {\n      case 'function':\n        if (true) {\n          const r = resolver.call(result, config[key], key, config);\n          if (!Number.isNaN(r)) result[key] = r;\n        } else {}\n        break;\n      case 'object':\n        result[key] = resolveWith(config[key], resolver);\n        break;\n      case 'boolean':\n        if (resolver) result[key] = config[key];\n        break;\n    }\n  }\n  return result;\n}\nfunction parse(newConfig, gestureKey, _config = {}) {\n  const _ref = newConfig,\n    {\n      target,\n      eventOptions,\n      window,\n      enabled,\n      transform\n    } = _ref,\n    rest = _objectWithoutProperties(_ref, _excluded);\n  _config.shared = resolveWith({\n    target,\n    eventOptions,\n    window,\n    enabled,\n    transform\n  }, sharedConfigResolver);\n  if (gestureKey) {\n    const resolver = _actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.C.get(gestureKey);\n    _config[gestureKey] = resolveWith((0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({\n      shared: _config.shared\n    }, rest), resolver);\n  } else {\n    for (const key in rest) {\n      const resolver = _actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.C.get(key);\n      if (resolver) {\n        _config[key] = resolveWith((0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({\n          shared: _config.shared\n        }, rest[key]), resolver);\n      } else if (true) {\n        if (!['drag', 'pinch', 'scroll', 'wheel', 'move', 'hover'].includes(key)) {\n          if (key === 'domTarget') {\n            throw Error(`[@use-gesture]: \\`domTarget\\` option has been renamed to \\`target\\`.`);\n          }\n          console.warn(`[@use-gesture]: Unknown config key \\`${key}\\` was used. Please read the documentation for further information.`);\n        }\n      }\n    }\n  }\n  return _config;\n}\n\nclass EventStore {\n  constructor(ctrl, gestureKey) {\n    (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"_listeners\", new Set());\n    this._ctrl = ctrl;\n    this._gestureKey = gestureKey;\n  }\n  add(element, device, action, handler, options) {\n    const listeners = this._listeners;\n    const type = (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.t)(device, action);\n    const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};\n    const eventOptions = (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, _options), options);\n    element.addEventListener(type, handler, eventOptions);\n    const remove = () => {\n      element.removeEventListener(type, handler, eventOptions);\n      listeners.delete(remove);\n    };\n    listeners.add(remove);\n    return remove;\n  }\n  clean() {\n    this._listeners.forEach(remove => remove());\n    this._listeners.clear();\n  }\n}\n\nclass TimeoutStore {\n  constructor() {\n    (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"_timeouts\", new Map());\n  }\n  add(key, callback, ms = 140, ...args) {\n    this.remove(key);\n    this._timeouts.set(key, window.setTimeout(callback, ms, ...args));\n  }\n  remove(key) {\n    const timeout = this._timeouts.get(key);\n    if (timeout) window.clearTimeout(timeout);\n  }\n  clean() {\n    this._timeouts.forEach(timeout => void window.clearTimeout(timeout));\n    this._timeouts.clear();\n  }\n}\n\nclass Controller {\n  constructor(handlers) {\n    (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"gestures\", new Set());\n    (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"_targetEventStore\", new EventStore(this));\n    (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"gestureEventStores\", {});\n    (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"gestureTimeoutStores\", {});\n    (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"handlers\", {});\n    (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"config\", {});\n    (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"pointerIds\", new Set());\n    (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"touchIds\", new Set());\n    (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, \"state\", {\n      shared: {\n        shiftKey: false,\n        metaKey: false,\n        ctrlKey: false,\n        altKey: false\n      }\n    });\n    resolveGestures(this, handlers);\n  }\n  setEventIds(event) {\n    if ((0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(event)) {\n      this.touchIds = new Set((0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(event));\n      return this.touchIds;\n    } else if ('pointerId' in event) {\n      if (event.type === 'pointerup' || event.type === 'pointercancel') this.pointerIds.delete(event.pointerId);else if (event.type === 'pointerdown') this.pointerIds.add(event.pointerId);\n      return this.pointerIds;\n    }\n  }\n  applyHandlers(handlers, nativeHandlers) {\n    this.handlers = handlers;\n    this.nativeHandlers = nativeHandlers;\n  }\n  applyConfig(config, gestureKey) {\n    this.config = parse(config, gestureKey, this.config);\n  }\n  clean() {\n    this._targetEventStore.clean();\n    for (const key of this.gestures) {\n      this.gestureEventStores[key].clean();\n      this.gestureTimeoutStores[key].clean();\n    }\n  }\n  effect() {\n    if (this.config.shared.target) this.bind();\n    return () => this._targetEventStore.clean();\n  }\n  bind(...args) {\n    const sharedConfig = this.config.shared;\n    const props = {};\n    let target;\n    if (sharedConfig.target) {\n      target = sharedConfig.target();\n      if (!target) return;\n    }\n    if (sharedConfig.enabled) {\n      for (const gestureKey of this.gestures) {\n        const gestureConfig = this.config[gestureKey];\n        const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target);\n        if (gestureConfig.enabled) {\n          const Engine = _actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.E.get(gestureKey);\n          new Engine(this, args, gestureKey).bind(bindFunction);\n        }\n      }\n      const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target);\n      for (const eventKey in this.nativeHandlers) {\n        nativeBindFunction(eventKey, '', event => this.nativeHandlers[eventKey]((0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, this.state.shared), {}, {\n          event,\n          args\n        })), undefined, true);\n      }\n    }\n    for (const handlerProp in props) {\n      props[handlerProp] = (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(...props[handlerProp]);\n    }\n    if (!target) return props;\n    for (const handlerProp in props) {\n      const {\n        device,\n        capture,\n        passive\n      } = (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.p)(handlerProp);\n      this._targetEventStore.add(target, device, '', props[handlerProp], {\n        capture,\n        passive\n      });\n    }\n  }\n}\nfunction setupGesture(ctrl, gestureKey) {\n  ctrl.gestures.add(gestureKey);\n  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);\n  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();\n}\nfunction resolveGestures(ctrl, internalHandlers) {\n  if (internalHandlers.drag) setupGesture(ctrl, 'drag');\n  if (internalHandlers.wheel) setupGesture(ctrl, 'wheel');\n  if (internalHandlers.scroll) setupGesture(ctrl, 'scroll');\n  if (internalHandlers.move) setupGesture(ctrl, 'move');\n  if (internalHandlers.pinch) setupGesture(ctrl, 'pinch');\n  if (internalHandlers.hover) setupGesture(ctrl, 'hover');\n}\nconst bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {\n  var _options$capture, _options$passive;\n  const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;\n  const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;\n  let handlerProp = isNative ? device : (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(device, action, capture);\n  if (withPassiveOption && passive) handlerProp += 'Passive';\n  props[handlerProp] = props[handlerProp] || [];\n  props[handlerProp].push(handler);\n};\n\nconst RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;\nfunction sortHandlers(_handlers) {\n  const native = {};\n  const handlers = {};\n  const actions = new Set();\n  for (let key in _handlers) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch);\n      handlers[key] = _handlers[key];\n    } else {\n      native[key] = _handlers[key];\n    }\n  }\n  return [handlers, native, actions];\n}\nfunction registerGesture(actions, handlers, handlerKey, key, internalHandlers, config) {\n  if (!actions.has(handlerKey)) return;\n  if (!_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.E.has(key)) {\n    if (true) {\n      console.warn(`[@use-gesture]: You've created a custom handler that that uses the \\`${key}\\` gesture but isn't properly configured.\\n\\nPlease add \\`${key}Action\\` when creating your handler.`);\n    }\n    return;\n  }\n  const startKey = handlerKey + 'Start';\n  const endKey = handlerKey + 'End';\n  const fn = state => {\n    let memo = undefined;\n    if (state.first && startKey in handlers) handlers[startKey](state);\n    if (handlerKey in handlers) memo = handlers[handlerKey](state);\n    if (state.last && endKey in handlers) handlers[endKey](state);\n    return memo;\n  };\n  internalHandlers[key] = fn;\n  config[key] = config[key] || {};\n}\nfunction parseMergedHandlers(mergedHandlers, mergedConfig) {\n  const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);\n  const internalHandlers = {};\n  registerGesture(actions, handlers, 'onDrag', 'drag', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onWheel', 'wheel', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onScroll', 'scroll', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onPinch', 'pinch', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onMove', 'move', internalHandlers, mergedConfig);\n  registerGesture(actions, handlers, 'onHover', 'hover', internalHandlers, mergedConfig);\n  return {\n    handlers: internalHandlers,\n    config: mergedConfig,\n    nativeHandlers\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVzZS1nZXN0dXJlL2NvcmUvZGlzdC91c2UtZ2VzdHVyZS1jb3JlLmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvZHVjdGlvbnByb2plY3QvLi9ub2RlX21vZHVsZXMvQHVzZS1nZXN0dXJlL2NvcmUvZGlzdC91c2UtZ2VzdHVyZS1jb3JlLmVzbS5qcz80MWVmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFMgYXMgU1VQUE9SVCwgQyBhcyBDb25maWdSZXNvbHZlck1hcCwgXyBhcyBfb2JqZWN0U3ByZWFkMiwgYSBhcyBfZGVmaW5lUHJvcGVydHksIHQgYXMgdG9Eb21FdmVudFR5cGUsIGkgYXMgaXNUb3VjaCwgYiBhcyB0b3VjaElkcywgRSBhcyBFbmdpbmVNYXAsIGMgYXMgY2hhaW4sIHAgYXMgcGFyc2VQcm9wLCBkIGFzIHRvSGFuZGxlclByb3AgfSBmcm9tICcuL2FjdGlvbnMtNzZiODY4M2UuZXNtLmpzJztcbmltcG9ydCAnLi9tYXRocy0wYWIzOWFlOS5lc20uanMnO1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5jb25zdCBzaGFyZWRDb25maWdSZXNvbHZlciA9IHtcbiAgdGFyZ2V0KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gKCkgPT4gJ2N1cnJlbnQnIGluIHZhbHVlID8gdmFsdWUuY3VycmVudCA6IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LFxuICBlbmFibGVkKHZhbHVlID0gdHJ1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgd2luZG93KHZhbHVlID0gU1VQUE9SVC5pc0Jyb3dzZXIgPyB3aW5kb3cgOiB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIGV2ZW50T3B0aW9ucyh7XG4gICAgcGFzc2l2ZSA9IHRydWUsXG4gICAgY2FwdHVyZSA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXNzaXZlLFxuICAgICAgY2FwdHVyZVxuICAgIH07XG4gIH0sXG4gIHRyYW5zZm9ybSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufTtcblxuY29uc3QgX2V4Y2x1ZGVkID0gW1widGFyZ2V0XCIsIFwiZXZlbnRPcHRpb25zXCIsIFwid2luZG93XCIsIFwiZW5hYmxlZFwiLCBcInRyYW5zZm9ybVwiXTtcbmZ1bmN0aW9uIHJlc29sdmVXaXRoKGNvbmZpZyA9IHt9LCByZXNvbHZlcnMpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3QgW2tleSwgcmVzb2x2ZXJdIG9mIE9iamVjdC5lbnRyaWVzKHJlc29sdmVycykpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiByZXNvbHZlcikge1xuICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICBjb25zdCByID0gcmVzb2x2ZXIuY2FsbChyZXN1bHQsIGNvbmZpZ1trZXldLCBrZXksIGNvbmZpZyk7XG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4ocikpIHJlc3VsdFtrZXldID0gcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHJlc29sdmVyLmNhbGwocmVzdWx0LCBjb25maWdba2V5XSwga2V5LCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmVzdWx0W2tleV0gPSByZXNvbHZlV2l0aChjb25maWdba2V5XSwgcmVzb2x2ZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICBpZiAocmVzb2x2ZXIpIHJlc3VsdFtrZXldID0gY29uZmlnW2tleV07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2UobmV3Q29uZmlnLCBnZXN0dXJlS2V5LCBfY29uZmlnID0ge30pIHtcbiAgY29uc3QgX3JlZiA9IG5ld0NvbmZpZyxcbiAgICB7XG4gICAgICB0YXJnZXQsXG4gICAgICBldmVudE9wdGlvbnMsXG4gICAgICB3aW5kb3csXG4gICAgICBlbmFibGVkLFxuICAgICAgdHJhbnNmb3JtXG4gICAgfSA9IF9yZWYsXG4gICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQpO1xuICBfY29uZmlnLnNoYXJlZCA9IHJlc29sdmVXaXRoKHtcbiAgICB0YXJnZXQsXG4gICAgZXZlbnRPcHRpb25zLFxuICAgIHdpbmRvdyxcbiAgICBlbmFibGVkLFxuICAgIHRyYW5zZm9ybVxuICB9LCBzaGFyZWRDb25maWdSZXNvbHZlcik7XG4gIGlmIChnZXN0dXJlS2V5KSB7XG4gICAgY29uc3QgcmVzb2x2ZXIgPSBDb25maWdSZXNvbHZlck1hcC5nZXQoZ2VzdHVyZUtleSk7XG4gICAgX2NvbmZpZ1tnZXN0dXJlS2V5XSA9IHJlc29sdmVXaXRoKF9vYmplY3RTcHJlYWQyKHtcbiAgICAgIHNoYXJlZDogX2NvbmZpZy5zaGFyZWRcbiAgICB9LCByZXN0KSwgcmVzb2x2ZXIpO1xuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3QpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVyID0gQ29uZmlnUmVzb2x2ZXJNYXAuZ2V0KGtleSk7XG4gICAgICBpZiAocmVzb2x2ZXIpIHtcbiAgICAgICAgX2NvbmZpZ1trZXldID0gcmVzb2x2ZVdpdGgoX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgIHNoYXJlZDogX2NvbmZpZy5zaGFyZWRcbiAgICAgICAgfSwgcmVzdFtrZXldKSwgcmVzb2x2ZXIpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBpZiAoIVsnZHJhZycsICdwaW5jaCcsICdzY3JvbGwnLCAnd2hlZWwnLCAnbW92ZScsICdob3ZlciddLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICBpZiAoa2V5ID09PSAnZG9tVGFyZ2V0Jykge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFtAdXNlLWdlc3R1cmVdOiBcXGBkb21UYXJnZXRcXGAgb3B0aW9uIGhhcyBiZWVuIHJlbmFtZWQgdG8gXFxgdGFyZ2V0XFxgLmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zb2xlLndhcm4oYFtAdXNlLWdlc3R1cmVdOiBVbmtub3duIGNvbmZpZyBrZXkgXFxgJHtrZXl9XFxgIHdhcyB1c2VkLiBQbGVhc2UgcmVhZCB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgZnVydGhlciBpbmZvcm1hdGlvbi5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gX2NvbmZpZztcbn1cblxuY2xhc3MgRXZlbnRTdG9yZSB7XG4gIGNvbnN0cnVjdG9yKGN0cmwsIGdlc3R1cmVLZXkpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbGlzdGVuZXJzXCIsIG5ldyBTZXQoKSk7XG4gICAgdGhpcy5fY3RybCA9IGN0cmw7XG4gICAgdGhpcy5fZ2VzdHVyZUtleSA9IGdlc3R1cmVLZXk7XG4gIH1cbiAgYWRkKGVsZW1lbnQsIGRldmljZSwgYWN0aW9uLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgIGNvbnN0IHR5cGUgPSB0b0RvbUV2ZW50VHlwZShkZXZpY2UsIGFjdGlvbik7XG4gICAgY29uc3QgX29wdGlvbnMgPSB0aGlzLl9nZXN0dXJlS2V5ID8gdGhpcy5fY3RybC5jb25maWdbdGhpcy5fZ2VzdHVyZUtleV0uZXZlbnRPcHRpb25zIDoge307XG4gICAgY29uc3QgZXZlbnRPcHRpb25zID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIF9vcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGV2ZW50T3B0aW9ucyk7XG4gICAgY29uc3QgcmVtb3ZlID0gKCkgPT4ge1xuICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGV2ZW50T3B0aW9ucyk7XG4gICAgICBsaXN0ZW5lcnMuZGVsZXRlKHJlbW92ZSk7XG4gICAgfTtcbiAgICBsaXN0ZW5lcnMuYWRkKHJlbW92ZSk7XG4gICAgcmV0dXJuIHJlbW92ZTtcbiAgfVxuICBjbGVhbigpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMuZm9yRWFjaChyZW1vdmUgPT4gcmVtb3ZlKCkpO1xuICAgIHRoaXMuX2xpc3RlbmVycy5jbGVhcigpO1xuICB9XG59XG5cbmNsYXNzIFRpbWVvdXRTdG9yZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90aW1lb3V0c1wiLCBuZXcgTWFwKCkpO1xuICB9XG4gIGFkZChrZXksIGNhbGxiYWNrLCBtcyA9IDE0MCwgLi4uYXJncykge1xuICAgIHRoaXMucmVtb3ZlKGtleSk7XG4gICAgdGhpcy5fdGltZW91dHMuc2V0KGtleSwgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIG1zLCAuLi5hcmdzKSk7XG4gIH1cbiAgcmVtb3ZlKGtleSkge1xuICAgIGNvbnN0IHRpbWVvdXQgPSB0aGlzLl90aW1lb3V0cy5nZXQoa2V5KTtcbiAgICBpZiAodGltZW91dCkgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgfVxuICBjbGVhbigpIHtcbiAgICB0aGlzLl90aW1lb3V0cy5mb3JFYWNoKHRpbWVvdXQgPT4gdm9pZCB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXQpKTtcbiAgICB0aGlzLl90aW1lb3V0cy5jbGVhcigpO1xuICB9XG59XG5cbmNsYXNzIENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihoYW5kbGVycykge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdlc3R1cmVzXCIsIG5ldyBTZXQoKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3RhcmdldEV2ZW50U3RvcmVcIiwgbmV3IEV2ZW50U3RvcmUodGhpcykpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdlc3R1cmVFdmVudFN0b3Jlc1wiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2VzdHVyZVRpbWVvdXRTdG9yZXNcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZXJzXCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb25maWdcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBvaW50ZXJJZHNcIiwgbmV3IFNldCgpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b3VjaElkc1wiLCBuZXcgU2V0KCkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXRlXCIsIHtcbiAgICAgIHNoYXJlZDoge1xuICAgICAgICBzaGlmdEtleTogZmFsc2UsXG4gICAgICAgIG1ldGFLZXk6IGZhbHNlLFxuICAgICAgICBjdHJsS2V5OiBmYWxzZSxcbiAgICAgICAgYWx0S2V5OiBmYWxzZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJlc29sdmVHZXN0dXJlcyh0aGlzLCBoYW5kbGVycyk7XG4gIH1cbiAgc2V0RXZlbnRJZHMoZXZlbnQpIHtcbiAgICBpZiAoaXNUb3VjaChldmVudCkpIHtcbiAgICAgIHRoaXMudG91Y2hJZHMgPSBuZXcgU2V0KHRvdWNoSWRzKGV2ZW50KSk7XG4gICAgICByZXR1cm4gdGhpcy50b3VjaElkcztcbiAgICB9IGVsc2UgaWYgKCdwb2ludGVySWQnIGluIGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3BvaW50ZXJ1cCcgfHwgZXZlbnQudHlwZSA9PT0gJ3BvaW50ZXJjYW5jZWwnKSB0aGlzLnBvaW50ZXJJZHMuZGVsZXRlKGV2ZW50LnBvaW50ZXJJZCk7ZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ3BvaW50ZXJkb3duJykgdGhpcy5wb2ludGVySWRzLmFkZChldmVudC5wb2ludGVySWQpO1xuICAgICAgcmV0dXJuIHRoaXMucG9pbnRlcklkcztcbiAgICB9XG4gIH1cbiAgYXBwbHlIYW5kbGVycyhoYW5kbGVycywgbmF0aXZlSGFuZGxlcnMpIHtcbiAgICB0aGlzLmhhbmRsZXJzID0gaGFuZGxlcnM7XG4gICAgdGhpcy5uYXRpdmVIYW5kbGVycyA9IG5hdGl2ZUhhbmRsZXJzO1xuICB9XG4gIGFwcGx5Q29uZmlnKGNvbmZpZywgZ2VzdHVyZUtleSkge1xuICAgIHRoaXMuY29uZmlnID0gcGFyc2UoY29uZmlnLCBnZXN0dXJlS2V5LCB0aGlzLmNvbmZpZyk7XG4gIH1cbiAgY2xlYW4oKSB7XG4gICAgdGhpcy5fdGFyZ2V0RXZlbnRTdG9yZS5jbGVhbigpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMuZ2VzdHVyZXMpIHtcbiAgICAgIHRoaXMuZ2VzdHVyZUV2ZW50U3RvcmVzW2tleV0uY2xlYW4oKTtcbiAgICAgIHRoaXMuZ2VzdHVyZVRpbWVvdXRTdG9yZXNba2V5XS5jbGVhbigpO1xuICAgIH1cbiAgfVxuICBlZmZlY3QoKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLnNoYXJlZC50YXJnZXQpIHRoaXMuYmluZCgpO1xuICAgIHJldHVybiAoKSA9PiB0aGlzLl90YXJnZXRFdmVudFN0b3JlLmNsZWFuKCk7XG4gIH1cbiAgYmluZCguLi5hcmdzKSB7XG4gICAgY29uc3Qgc2hhcmVkQ29uZmlnID0gdGhpcy5jb25maWcuc2hhcmVkO1xuICAgIGNvbnN0IHByb3BzID0ge307XG4gICAgbGV0IHRhcmdldDtcbiAgICBpZiAoc2hhcmVkQ29uZmlnLnRhcmdldCkge1xuICAgICAgdGFyZ2V0ID0gc2hhcmVkQ29uZmlnLnRhcmdldCgpO1xuICAgICAgaWYgKCF0YXJnZXQpIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNoYXJlZENvbmZpZy5lbmFibGVkKSB7XG4gICAgICBmb3IgKGNvbnN0IGdlc3R1cmVLZXkgb2YgdGhpcy5nZXN0dXJlcykge1xuICAgICAgICBjb25zdCBnZXN0dXJlQ29uZmlnID0gdGhpcy5jb25maWdbZ2VzdHVyZUtleV07XG4gICAgICAgIGNvbnN0IGJpbmRGdW5jdGlvbiA9IGJpbmRUb1Byb3BzKHByb3BzLCBnZXN0dXJlQ29uZmlnLmV2ZW50T3B0aW9ucywgISF0YXJnZXQpO1xuICAgICAgICBpZiAoZ2VzdHVyZUNvbmZpZy5lbmFibGVkKSB7XG4gICAgICAgICAgY29uc3QgRW5naW5lID0gRW5naW5lTWFwLmdldChnZXN0dXJlS2V5KTtcbiAgICAgICAgICBuZXcgRW5naW5lKHRoaXMsIGFyZ3MsIGdlc3R1cmVLZXkpLmJpbmQoYmluZEZ1bmN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgbmF0aXZlQmluZEZ1bmN0aW9uID0gYmluZFRvUHJvcHMocHJvcHMsIHNoYXJlZENvbmZpZy5ldmVudE9wdGlvbnMsICEhdGFyZ2V0KTtcbiAgICAgIGZvciAoY29uc3QgZXZlbnRLZXkgaW4gdGhpcy5uYXRpdmVIYW5kbGVycykge1xuICAgICAgICBuYXRpdmVCaW5kRnVuY3Rpb24oZXZlbnRLZXksICcnLCBldmVudCA9PiB0aGlzLm5hdGl2ZUhhbmRsZXJzW2V2ZW50S2V5XShfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgdGhpcy5zdGF0ZS5zaGFyZWQpLCB7fSwge1xuICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgIGFyZ3NcbiAgICAgICAgfSkpLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGhhbmRsZXJQcm9wIGluIHByb3BzKSB7XG4gICAgICBwcm9wc1toYW5kbGVyUHJvcF0gPSBjaGFpbiguLi5wcm9wc1toYW5kbGVyUHJvcF0pO1xuICAgIH1cbiAgICBpZiAoIXRhcmdldCkgcmV0dXJuIHByb3BzO1xuICAgIGZvciAoY29uc3QgaGFuZGxlclByb3AgaW4gcHJvcHMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGV2aWNlLFxuICAgICAgICBjYXB0dXJlLFxuICAgICAgICBwYXNzaXZlXG4gICAgICB9ID0gcGFyc2VQcm9wKGhhbmRsZXJQcm9wKTtcbiAgICAgIHRoaXMuX3RhcmdldEV2ZW50U3RvcmUuYWRkKHRhcmdldCwgZGV2aWNlLCAnJywgcHJvcHNbaGFuZGxlclByb3BdLCB7XG4gICAgICAgIGNhcHR1cmUsXG4gICAgICAgIHBhc3NpdmVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2V0dXBHZXN0dXJlKGN0cmwsIGdlc3R1cmVLZXkpIHtcbiAgY3RybC5nZXN0dXJlcy5hZGQoZ2VzdHVyZUtleSk7XG4gIGN0cmwuZ2VzdHVyZUV2ZW50U3RvcmVzW2dlc3R1cmVLZXldID0gbmV3IEV2ZW50U3RvcmUoY3RybCwgZ2VzdHVyZUtleSk7XG4gIGN0cmwuZ2VzdHVyZVRpbWVvdXRTdG9yZXNbZ2VzdHVyZUtleV0gPSBuZXcgVGltZW91dFN0b3JlKCk7XG59XG5mdW5jdGlvbiByZXNvbHZlR2VzdHVyZXMoY3RybCwgaW50ZXJuYWxIYW5kbGVycykge1xuICBpZiAoaW50ZXJuYWxIYW5kbGVycy5kcmFnKSBzZXR1cEdlc3R1cmUoY3RybCwgJ2RyYWcnKTtcbiAgaWYgKGludGVybmFsSGFuZGxlcnMud2hlZWwpIHNldHVwR2VzdHVyZShjdHJsLCAnd2hlZWwnKTtcbiAgaWYgKGludGVybmFsSGFuZGxlcnMuc2Nyb2xsKSBzZXR1cEdlc3R1cmUoY3RybCwgJ3Njcm9sbCcpO1xuICBpZiAoaW50ZXJuYWxIYW5kbGVycy5tb3ZlKSBzZXR1cEdlc3R1cmUoY3RybCwgJ21vdmUnKTtcbiAgaWYgKGludGVybmFsSGFuZGxlcnMucGluY2gpIHNldHVwR2VzdHVyZShjdHJsLCAncGluY2gnKTtcbiAgaWYgKGludGVybmFsSGFuZGxlcnMuaG92ZXIpIHNldHVwR2VzdHVyZShjdHJsLCAnaG92ZXInKTtcbn1cbmNvbnN0IGJpbmRUb1Byb3BzID0gKHByb3BzLCBldmVudE9wdGlvbnMsIHdpdGhQYXNzaXZlT3B0aW9uKSA9PiAoZGV2aWNlLCBhY3Rpb24sIGhhbmRsZXIsIG9wdGlvbnMgPSB7fSwgaXNOYXRpdmUgPSBmYWxzZSkgPT4ge1xuICB2YXIgX29wdGlvbnMkY2FwdHVyZSwgX29wdGlvbnMkcGFzc2l2ZTtcbiAgY29uc3QgY2FwdHVyZSA9IChfb3B0aW9ucyRjYXB0dXJlID0gb3B0aW9ucy5jYXB0dXJlKSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRjYXB0dXJlICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRjYXB0dXJlIDogZXZlbnRPcHRpb25zLmNhcHR1cmU7XG4gIGNvbnN0IHBhc3NpdmUgPSAoX29wdGlvbnMkcGFzc2l2ZSA9IG9wdGlvbnMucGFzc2l2ZSkgIT09IG51bGwgJiYgX29wdGlvbnMkcGFzc2l2ZSAhPT0gdm9pZCAwID8gX29wdGlvbnMkcGFzc2l2ZSA6IGV2ZW50T3B0aW9ucy5wYXNzaXZlO1xuICBsZXQgaGFuZGxlclByb3AgPSBpc05hdGl2ZSA/IGRldmljZSA6IHRvSGFuZGxlclByb3AoZGV2aWNlLCBhY3Rpb24sIGNhcHR1cmUpO1xuICBpZiAod2l0aFBhc3NpdmVPcHRpb24gJiYgcGFzc2l2ZSkgaGFuZGxlclByb3AgKz0gJ1Bhc3NpdmUnO1xuICBwcm9wc1toYW5kbGVyUHJvcF0gPSBwcm9wc1toYW5kbGVyUHJvcF0gfHwgW107XG4gIHByb3BzW2hhbmRsZXJQcm9wXS5wdXNoKGhhbmRsZXIpO1xufTtcblxuY29uc3QgUkVfTk9UX05BVElWRSA9IC9eb24oRHJhZ3xXaGVlbHxTY3JvbGx8TW92ZXxQaW5jaHxIb3ZlcikvO1xuZnVuY3Rpb24gc29ydEhhbmRsZXJzKF9oYW5kbGVycykge1xuICBjb25zdCBuYXRpdmUgPSB7fTtcbiAgY29uc3QgaGFuZGxlcnMgPSB7fTtcbiAgY29uc3QgYWN0aW9ucyA9IG5ldyBTZXQoKTtcbiAgZm9yIChsZXQga2V5IGluIF9oYW5kbGVycykge1xuICAgIGlmIChSRV9OT1RfTkFUSVZFLnRlc3Qoa2V5KSkge1xuICAgICAgYWN0aW9ucy5hZGQoUmVnRXhwLmxhc3RNYXRjaCk7XG4gICAgICBoYW5kbGVyc1trZXldID0gX2hhbmRsZXJzW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hdGl2ZVtrZXldID0gX2hhbmRsZXJzW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBbaGFuZGxlcnMsIG5hdGl2ZSwgYWN0aW9uc107XG59XG5mdW5jdGlvbiByZWdpc3Rlckdlc3R1cmUoYWN0aW9ucywgaGFuZGxlcnMsIGhhbmRsZXJLZXksIGtleSwgaW50ZXJuYWxIYW5kbGVycywgY29uZmlnKSB7XG4gIGlmICghYWN0aW9ucy5oYXMoaGFuZGxlcktleSkpIHJldHVybjtcbiAgaWYgKCFFbmdpbmVNYXAuaGFzKGtleSkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihgW0B1c2UtZ2VzdHVyZV06IFlvdSd2ZSBjcmVhdGVkIGEgY3VzdG9tIGhhbmRsZXIgdGhhdCB0aGF0IHVzZXMgdGhlIFxcYCR7a2V5fVxcYCBnZXN0dXJlIGJ1dCBpc24ndCBwcm9wZXJseSBjb25maWd1cmVkLlxcblxcblBsZWFzZSBhZGQgXFxgJHtrZXl9QWN0aW9uXFxgIHdoZW4gY3JlYXRpbmcgeW91ciBoYW5kbGVyLmApO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc3RhcnRLZXkgPSBoYW5kbGVyS2V5ICsgJ1N0YXJ0JztcbiAgY29uc3QgZW5kS2V5ID0gaGFuZGxlcktleSArICdFbmQnO1xuICBjb25zdCBmbiA9IHN0YXRlID0+IHtcbiAgICBsZXQgbWVtbyA9IHVuZGVmaW5lZDtcbiAgICBpZiAoc3RhdGUuZmlyc3QgJiYgc3RhcnRLZXkgaW4gaGFuZGxlcnMpIGhhbmRsZXJzW3N0YXJ0S2V5XShzdGF0ZSk7XG4gICAgaWYgKGhhbmRsZXJLZXkgaW4gaGFuZGxlcnMpIG1lbW8gPSBoYW5kbGVyc1toYW5kbGVyS2V5XShzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLmxhc3QgJiYgZW5kS2V5IGluIGhhbmRsZXJzKSBoYW5kbGVyc1tlbmRLZXldKHN0YXRlKTtcbiAgICByZXR1cm4gbWVtbztcbiAgfTtcbiAgaW50ZXJuYWxIYW5kbGVyc1trZXldID0gZm47XG4gIGNvbmZpZ1trZXldID0gY29uZmlnW2tleV0gfHwge307XG59XG5mdW5jdGlvbiBwYXJzZU1lcmdlZEhhbmRsZXJzKG1lcmdlZEhhbmRsZXJzLCBtZXJnZWRDb25maWcpIHtcbiAgY29uc3QgW2hhbmRsZXJzLCBuYXRpdmVIYW5kbGVycywgYWN0aW9uc10gPSBzb3J0SGFuZGxlcnMobWVyZ2VkSGFuZGxlcnMpO1xuICBjb25zdCBpbnRlcm5hbEhhbmRsZXJzID0ge307XG4gIHJlZ2lzdGVyR2VzdHVyZShhY3Rpb25zLCBoYW5kbGVycywgJ29uRHJhZycsICdkcmFnJywgaW50ZXJuYWxIYW5kbGVycywgbWVyZ2VkQ29uZmlnKTtcbiAgcmVnaXN0ZXJHZXN0dXJlKGFjdGlvbnMsIGhhbmRsZXJzLCAnb25XaGVlbCcsICd3aGVlbCcsIGludGVybmFsSGFuZGxlcnMsIG1lcmdlZENvbmZpZyk7XG4gIHJlZ2lzdGVyR2VzdHVyZShhY3Rpb25zLCBoYW5kbGVycywgJ29uU2Nyb2xsJywgJ3Njcm9sbCcsIGludGVybmFsSGFuZGxlcnMsIG1lcmdlZENvbmZpZyk7XG4gIHJlZ2lzdGVyR2VzdHVyZShhY3Rpb25zLCBoYW5kbGVycywgJ29uUGluY2gnLCAncGluY2gnLCBpbnRlcm5hbEhhbmRsZXJzLCBtZXJnZWRDb25maWcpO1xuICByZWdpc3Rlckdlc3R1cmUoYWN0aW9ucywgaGFuZGxlcnMsICdvbk1vdmUnLCAnbW92ZScsIGludGVybmFsSGFuZGxlcnMsIG1lcmdlZENvbmZpZyk7XG4gIHJlZ2lzdGVyR2VzdHVyZShhY3Rpb25zLCBoYW5kbGVycywgJ29uSG92ZXInLCAnaG92ZXInLCBpbnRlcm5hbEhhbmRsZXJzLCBtZXJnZWRDb25maWcpO1xuICByZXR1cm4ge1xuICAgIGhhbmRsZXJzOiBpbnRlcm5hbEhhbmRsZXJzLFxuICAgIGNvbmZpZzogbWVyZ2VkQ29uZmlnLFxuICAgIG5hdGl2ZUhhbmRsZXJzXG4gIH07XG59XG5cbmV4cG9ydCB7IENvbnRyb2xsZXIsIHBhcnNlTWVyZ2VkSGFuZGxlcnMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@use-gesture/core/dist/use-gesture-core.esm.js\n");

/***/ }),

/***/ "./node_modules/@use-gesture/core/types/dist/use-gesture-core-types.esm.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@use-gesture/core/types/dist/use-gesture-core-types.esm.js ***!
  \*********************************************************************************/
/***/ (function() {

eval("\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVzZS1nZXN0dXJlL2NvcmUvdHlwZXMvZGlzdC91c2UtZ2VzdHVyZS1jb3JlLXR5cGVzLmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2R1Y3Rpb25wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL0B1c2UtZ2VzdHVyZS9jb3JlL3R5cGVzL2Rpc3QvdXNlLWdlc3R1cmUtY29yZS10eXBlcy5lc20uanM/MWFlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@use-gesture/core/types/dist/use-gesture-core-types.esm.js\n");

/***/ }),

/***/ "./node_modules/@use-gesture/core/utils/dist/use-gesture-core-utils.esm.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@use-gesture/core/utils/dist/use-gesture-core-utils.esm.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"rubberbandIfOutOfBounds\": function() { return /* reexport safe */ _dist_maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.r; }\n/* harmony export */ });\n/* harmony import */ var _dist_maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dist/maths-0ab39ae9.esm.js */ \"./node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVzZS1nZXN0dXJlL2NvcmUvdXRpbHMvZGlzdC91c2UtZ2VzdHVyZS1jb3JlLXV0aWxzLmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvZHVjdGlvbnByb2plY3QvLi9ub2RlX21vZHVsZXMvQHVzZS1nZXN0dXJlL2NvcmUvdXRpbHMvZGlzdC91c2UtZ2VzdHVyZS1jb3JlLXV0aWxzLmVzbS5qcz9kZThlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IHIgYXMgcnViYmVyYmFuZElmT3V0T2ZCb3VuZHMgfSBmcm9tICcuLi8uLi9kaXN0L21hdGhzLTBhYjM5YWU5LmVzbS5qcyc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@use-gesture/core/utils/dist/use-gesture-core-utils.esm.js\n");

/***/ }),

/***/ "./node_modules/@use-gesture/react/dist/use-gesture-react.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@use-gesture/react/dist/use-gesture-react.esm.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ConfigResolverMap\": function() { return /* reexport safe */ _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.ConfigResolverMap; },\n/* harmony export */   \"EngineMap\": function() { return /* reexport safe */ _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.EngineMap; },\n/* harmony export */   \"createUseGesture\": function() { return /* binding */ createUseGesture; },\n/* harmony export */   \"dragAction\": function() { return /* reexport safe */ _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.dragAction; },\n/* harmony export */   \"hoverAction\": function() { return /* reexport safe */ _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.hoverAction; },\n/* harmony export */   \"moveAction\": function() { return /* reexport safe */ _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.moveAction; },\n/* harmony export */   \"pinchAction\": function() { return /* reexport safe */ _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.pinchAction; },\n/* harmony export */   \"registerAction\": function() { return /* reexport safe */ _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.registerAction; },\n/* harmony export */   \"rubberbandIfOutOfBounds\": function() { return /* reexport safe */ _use_gesture_core_utils__WEBPACK_IMPORTED_MODULE_2__.rubberbandIfOutOfBounds; },\n/* harmony export */   \"scrollAction\": function() { return /* reexport safe */ _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.scrollAction; },\n/* harmony export */   \"useDrag\": function() { return /* binding */ useDrag; },\n/* harmony export */   \"useGesture\": function() { return /* binding */ useGesture; },\n/* harmony export */   \"useHover\": function() { return /* binding */ useHover; },\n/* harmony export */   \"useMove\": function() { return /* binding */ useMove; },\n/* harmony export */   \"usePinch\": function() { return /* binding */ usePinch; },\n/* harmony export */   \"useScroll\": function() { return /* binding */ useScroll; },\n/* harmony export */   \"useWheel\": function() { return /* binding */ useWheel; },\n/* harmony export */   \"wheelAction\": function() { return /* reexport safe */ _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.wheelAction; }\n/* harmony export */ });\n/* harmony import */ var _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @use-gesture/core/actions */ \"./node_modules/@use-gesture/core/actions/dist/use-gesture-core-actions.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _use_gesture_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @use-gesture/core */ \"./node_modules/@use-gesture/core/dist/use-gesture-core.esm.js\");\n/* harmony import */ var _use_gesture_core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @use-gesture/core/utils */ \"./node_modules/@use-gesture/core/utils/dist/use-gesture-core-utils.esm.js\");\n/* harmony import */ var _use_gesture_core_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @use-gesture/core/types */ \"./node_modules/@use-gesture/core/types/dist/use-gesture-core-types.esm.js\");\n/* harmony import */ var _use_gesture_core_types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_use_gesture_core_types__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _use_gesture_core_types__WEBPACK_IMPORTED_MODULE_3__) if([\"default\",\"createUseGesture\",\"useDrag\",\"useGesture\",\"useHover\",\"useMove\",\"usePinch\",\"useScroll\",\"useWheel\",\"ConfigResolverMap\",\"EngineMap\",\"dragAction\",\"hoverAction\",\"moveAction\",\"pinchAction\",\"registerAction\",\"scrollAction\",\"wheelAction\",\"rubberbandIfOutOfBounds\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _use_gesture_core_types__WEBPACK_IMPORTED_MODULE_3__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n\n\n\n\nfunction useRecognizers(handlers, config = {}, gestureKey, nativeHandlers) {\n  const ctrl = react__WEBPACK_IMPORTED_MODULE_1___default().useMemo(() => new _use_gesture_core__WEBPACK_IMPORTED_MODULE_4__.Controller(handlers), []);\n  ctrl.applyHandlers(handlers, nativeHandlers);\n  ctrl.applyConfig(config, gestureKey);\n  react__WEBPACK_IMPORTED_MODULE_1___default().useEffect(ctrl.effect.bind(ctrl));\n  react__WEBPACK_IMPORTED_MODULE_1___default().useEffect(() => {\n    return ctrl.clean.bind(ctrl);\n  }, []);\n  if (config.target === undefined) {\n    return ctrl.bind.bind(ctrl);\n  }\n  return undefined;\n}\n\nfunction useDrag(handler, config) {\n  (0,_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.registerAction)(_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.dragAction);\n  return useRecognizers({\n    drag: handler\n  }, config || {}, 'drag');\n}\n\nfunction usePinch(handler, config) {\n  (0,_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.registerAction)(_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.pinchAction);\n  return useRecognizers({\n    pinch: handler\n  }, config || {}, 'pinch');\n}\n\nfunction useWheel(handler, config) {\n  (0,_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.registerAction)(_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.wheelAction);\n  return useRecognizers({\n    wheel: handler\n  }, config || {}, 'wheel');\n}\n\nfunction useScroll(handler, config) {\n  (0,_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.registerAction)(_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.scrollAction);\n  return useRecognizers({\n    scroll: handler\n  }, config || {}, 'scroll');\n}\n\nfunction useMove(handler, config) {\n  (0,_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.registerAction)(_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.moveAction);\n  return useRecognizers({\n    move: handler\n  }, config || {}, 'move');\n}\n\nfunction useHover(handler, config) {\n  (0,_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.registerAction)(_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.hoverAction);\n  return useRecognizers({\n    hover: handler\n  }, config || {}, 'hover');\n}\n\nfunction createUseGesture(actions) {\n  actions.forEach(_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.registerAction);\n  return function useGesture(_handlers, _config) {\n    const {\n      handlers,\n      nativeHandlers,\n      config\n    } = (0,_use_gesture_core__WEBPACK_IMPORTED_MODULE_4__.parseMergedHandlers)(_handlers, _config || {});\n    return useRecognizers(handlers, config, undefined, nativeHandlers);\n  };\n}\n\nfunction useGesture(handlers, config) {\n  const hook = createUseGesture([_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.dragAction, _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.pinchAction, _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.scrollAction, _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.wheelAction, _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.moveAction, _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.hoverAction]);\n  return hook(handlers, config || {});\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVzZS1nZXN0dXJlL3JlYWN0L2Rpc3QvdXNlLWdlc3R1cmUtcmVhY3QuZXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9kdWN0aW9ucHJvamVjdC8uL25vZGVfbW9kdWxlcy9AdXNlLWdlc3R1cmUvcmVhY3QvZGlzdC91c2UtZ2VzdHVyZS1yZWFjdC5lc20uanM/M2I3YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZWdpc3RlckFjdGlvbiwgZHJhZ0FjdGlvbiwgcGluY2hBY3Rpb24sIHdoZWVsQWN0aW9uLCBzY3JvbGxBY3Rpb24sIG1vdmVBY3Rpb24sIGhvdmVyQWN0aW9uIH0gZnJvbSAnQHVzZS1nZXN0dXJlL2NvcmUvYWN0aW9ucyc7XG5leHBvcnQgKiBmcm9tICdAdXNlLWdlc3R1cmUvY29yZS9hY3Rpb25zJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBDb250cm9sbGVyLCBwYXJzZU1lcmdlZEhhbmRsZXJzIH0gZnJvbSAnQHVzZS1nZXN0dXJlL2NvcmUnO1xuZXhwb3J0ICogZnJvbSAnQHVzZS1nZXN0dXJlL2NvcmUvdXRpbHMnO1xuZXhwb3J0ICogZnJvbSAnQHVzZS1nZXN0dXJlL2NvcmUvdHlwZXMnO1xuXG5mdW5jdGlvbiB1c2VSZWNvZ25pemVycyhoYW5kbGVycywgY29uZmlnID0ge30sIGdlc3R1cmVLZXksIG5hdGl2ZUhhbmRsZXJzKSB7XG4gIGNvbnN0IGN0cmwgPSBSZWFjdC51c2VNZW1vKCgpID0+IG5ldyBDb250cm9sbGVyKGhhbmRsZXJzKSwgW10pO1xuICBjdHJsLmFwcGx5SGFuZGxlcnMoaGFuZGxlcnMsIG5hdGl2ZUhhbmRsZXJzKTtcbiAgY3RybC5hcHBseUNvbmZpZyhjb25maWcsIGdlc3R1cmVLZXkpO1xuICBSZWFjdC51c2VFZmZlY3QoY3RybC5lZmZlY3QuYmluZChjdHJsKSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIGN0cmwuY2xlYW4uYmluZChjdHJsKTtcbiAgfSwgW10pO1xuICBpZiAoY29uZmlnLnRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGN0cmwuYmluZC5iaW5kKGN0cmwpO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHVzZURyYWcoaGFuZGxlciwgY29uZmlnKSB7XG4gIHJlZ2lzdGVyQWN0aW9uKGRyYWdBY3Rpb24pO1xuICByZXR1cm4gdXNlUmVjb2duaXplcnMoe1xuICAgIGRyYWc6IGhhbmRsZXJcbiAgfSwgY29uZmlnIHx8IHt9LCAnZHJhZycpO1xufVxuXG5mdW5jdGlvbiB1c2VQaW5jaChoYW5kbGVyLCBjb25maWcpIHtcbiAgcmVnaXN0ZXJBY3Rpb24ocGluY2hBY3Rpb24pO1xuICByZXR1cm4gdXNlUmVjb2duaXplcnMoe1xuICAgIHBpbmNoOiBoYW5kbGVyXG4gIH0sIGNvbmZpZyB8fCB7fSwgJ3BpbmNoJyk7XG59XG5cbmZ1bmN0aW9uIHVzZVdoZWVsKGhhbmRsZXIsIGNvbmZpZykge1xuICByZWdpc3RlckFjdGlvbih3aGVlbEFjdGlvbik7XG4gIHJldHVybiB1c2VSZWNvZ25pemVycyh7XG4gICAgd2hlZWw6IGhhbmRsZXJcbiAgfSwgY29uZmlnIHx8IHt9LCAnd2hlZWwnKTtcbn1cblxuZnVuY3Rpb24gdXNlU2Nyb2xsKGhhbmRsZXIsIGNvbmZpZykge1xuICByZWdpc3RlckFjdGlvbihzY3JvbGxBY3Rpb24pO1xuICByZXR1cm4gdXNlUmVjb2duaXplcnMoe1xuICAgIHNjcm9sbDogaGFuZGxlclxuICB9LCBjb25maWcgfHwge30sICdzY3JvbGwnKTtcbn1cblxuZnVuY3Rpb24gdXNlTW92ZShoYW5kbGVyLCBjb25maWcpIHtcbiAgcmVnaXN0ZXJBY3Rpb24obW92ZUFjdGlvbik7XG4gIHJldHVybiB1c2VSZWNvZ25pemVycyh7XG4gICAgbW92ZTogaGFuZGxlclxuICB9LCBjb25maWcgfHwge30sICdtb3ZlJyk7XG59XG5cbmZ1bmN0aW9uIHVzZUhvdmVyKGhhbmRsZXIsIGNvbmZpZykge1xuICByZWdpc3RlckFjdGlvbihob3ZlckFjdGlvbik7XG4gIHJldHVybiB1c2VSZWNvZ25pemVycyh7XG4gICAgaG92ZXI6IGhhbmRsZXJcbiAgfSwgY29uZmlnIHx8IHt9LCAnaG92ZXInKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVXNlR2VzdHVyZShhY3Rpb25zKSB7XG4gIGFjdGlvbnMuZm9yRWFjaChyZWdpc3RlckFjdGlvbik7XG4gIHJldHVybiBmdW5jdGlvbiB1c2VHZXN0dXJlKF9oYW5kbGVycywgX2NvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGhhbmRsZXJzLFxuICAgICAgbmF0aXZlSGFuZGxlcnMsXG4gICAgICBjb25maWdcbiAgICB9ID0gcGFyc2VNZXJnZWRIYW5kbGVycyhfaGFuZGxlcnMsIF9jb25maWcgfHwge30pO1xuICAgIHJldHVybiB1c2VSZWNvZ25pemVycyhoYW5kbGVycywgY29uZmlnLCB1bmRlZmluZWQsIG5hdGl2ZUhhbmRsZXJzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlR2VzdHVyZShoYW5kbGVycywgY29uZmlnKSB7XG4gIGNvbnN0IGhvb2sgPSBjcmVhdGVVc2VHZXN0dXJlKFtkcmFnQWN0aW9uLCBwaW5jaEFjdGlvbiwgc2Nyb2xsQWN0aW9uLCB3aGVlbEFjdGlvbiwgbW92ZUFjdGlvbiwgaG92ZXJBY3Rpb25dKTtcbiAgcmV0dXJuIGhvb2soaGFuZGxlcnMsIGNvbmZpZyB8fCB7fSk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVVzZUdlc3R1cmUsIHVzZURyYWcsIHVzZUdlc3R1cmUsIHVzZUhvdmVyLCB1c2VNb3ZlLCB1c2VQaW5jaCwgdXNlU2Nyb2xsLCB1c2VXaGVlbCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@use-gesture/react/dist/use-gesture-react.esm.js\n");

/***/ })

}]);